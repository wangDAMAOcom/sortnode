/*
 * Copyright (C) 2013 Great OpenSource Inc. All Rights Reserved.
 */
#include "mysql_plan.h"

#include <async_task_manager.h>
#include <backend.h>
#include <basic.h>
#include <cluster_status.h>
#include <config.h>
#include <cross_node_join_manager.h>
#include <data_space.h>
#include <exception.h>
#include <frontend.h>
#include <log.h>
#include <log_tool.h>
#include <monitor_point_handler.h>
#include <mul_sync_topic.h>
#include <multiple.h>
#include <mysql_migrate_util.h>
#include <mysql_parser.h>
#include <mysql_xa_transaction.h>
#include <mysqld_error.h>
#include <parser.h>
#include <partition_method.h>
#include <plan.h>
#include <socket_base_manager.h>
#include <sql_parser.h>
#include <xa_transaction.h>

#include <boost/algorithm/string.hpp>
#include <boost/date_time/posix_time/posix_time.hpp>
#include <boost/format.hpp>

#include "mysql_connection.h"
#include "mysql_driver.h"
#include "mysql_request.h"
#include "sha1.h"

using namespace dbscale;
using namespace dbscale::sql;
using namespace dbscale::plan;
using namespace dbscale::mysql;

#define DBSCALE_BACKEND_THREADS_NUMS 9
#define CHECK_ERROR_INFO "CHECK TABLE GET ERROR"
#define MAX_DEAD_CONN_PER_MIN 1000

#define STR_LEN_INDEX(start, end) (end) - (start) + 1

struct dbscale_threads_str {
  const char *thread_name;
  const char *desc;
  const char *extra;
};

struct dbscale_threads_str threads_message[DBSCALE_BACKEND_THREADS_NUMS] = {
    {"MySQLXA_purge_thread ",
     "Backend thread used to purge XA transaction meta data", ""},
    {"XA_readonly_conn_handler",
     "Backend thread used to handle read-only connections during an XA "
     "transaction",
     ""},
    {"MigrateCleanThread  ",
     "Backend thread used to do purge tasks after a migration job", ""},
    {"MultipleSyncTool",
     "Backend thread used to handle sync messages when in multiple-dbscale "
     "mode",
     ""},
    {"MultipleManager  ",
     "Backend thread used to handle multiple dbscale related situations", ""},
    {"LicenseCheck", "Backend thread used to check license status", ""},
    {"ManagerThread ", "Backend thread used to do the memory free work", ""},
    {"CrossNodeJoinCleanThread",
     "Backend thread used to purge cross node join related meta data", ""},
    {"MessageHandler ", "Backend thread used to handle different messages", ""},
};

namespace dbscale {
namespace sql {
void get_aggregate_functions(record_scan *rs, list<AggregateDesc> &aggr_list);
extern void adjust_shard_schema(const char *sql_schema, const char *cur_schema,
                                string &new_schema,
                                unsigned int virtual_machine_id,
                                unsigned int partition_id);
}  // namespace sql
}  // namespace dbscale
namespace dbscale {
Schema *get_or_create_schema(string schema_name);
extern void sync_migrate_change_topo(string topic_name, string param);
Schema *get_migrate_schema(string schema_name) {
  Backend *backend = Backend::instance();
  Schema *schema = backend->find_schema(schema_name.c_str());
  if (schema == NULL) {
    LOG_ERROR("get exception dring get schema[%s], plz dynamic add it\n",
              schema_name.c_str());
    throw Error("get exception dring get schema");
  }
  return schema;
}

bool handle_tokudb_lock_timeout(Connection *conn, Packet *packet) {
  try {
    if (support_tokudb && conn && packet) {
      MySQLErrorResponse error(packet);
      error.unpack();
      if (error.get_error_code() == 1205) {
        string tokudb_last_lock_timeout;
        conn->query_for_one_value("select @@tokudb_last_lock_timeout",
                                  tokudb_last_lock_timeout, 0);
        LOG_INFO("select @@tokudb_last_lock_timeout result is :%s\n",
                 tokudb_last_lock_timeout.c_str());
        // result like below:
        //@@tokudb_last_lock_timeout: {"mysql_thread_id":6052,
        //"dbname":"./wen/t1-main", "requesting_txnid":1558,
        //"blocking_txnid":1554, "key":"0001000000"}
        int pos_start, pos_end;
        pos_start = tokudb_last_lock_timeout.find("\"blocking_txnid\":");
        if (pos_start >= 0) {
          pos_end = tokudb_last_lock_timeout.find(",", pos_start);
          string blocking_txnid = tokudb_last_lock_timeout.substr(
              pos_start + 17, pos_end - pos_start - 17);
          string sql =
              "select locks_mysql_thread_id from "
              "information_schema.TokuDB_locks where locks_trx_id=";
          sql += blocking_txnid;
          LOG_INFO("generate get lock sql:%s\n", sql.c_str());

          vector<string> vec;
          TimeValue tv(backend_sql_net_timeout);
          conn->query_for_one_column(sql.c_str(), 0, &vec, &tv, true);
          vector<string>::iterator it;
          LOG_INFO("plz execute below command:\n");
          for (it = vec.begin(); it != vec.end(); it++) {
            LOG_INFO(
                "DBSCALE SHOW SESSION ID WITH DATASERVER = %s CONNECTION = "
                "%s;\n",
                conn->get_server()->get_name(), it->c_str());
          }
          LOG_INFO(
              "plz kill the session to release lock if necessary by "
              "command:\"kill cluster_id session_id\"\n");
        }
      }
    }
  } catch (exception &e) {
    LOG_ERROR("handle_tokudb_lock_timeout get exception [%s]\n", e.what());
    return true;
  }
  return false;
}
namespace mysql {
#define MAX_PACKET_SIZE ((2 << 23) - 1)

// define the max length of string number, like max_legth=strlen("1234567890");
#define MAX_LENGTH_NUM (10)

static string find_and_replace_quota(const char *sql) {
  string tmp_sql(sql);
  size_t pos = tmp_sql.find("\"");
  while (pos != string::npos) {
    tmp_sql.replace(pos, 1, "\\\"");
    pos = tmp_sql.find("\"", pos + 2);
  }
  return tmp_sql;
}

void transfer_packet(Packet **old_packet, Packet **new_packet) {
  char *p = (*old_packet)->base();
  char *data = (*old_packet)->rd_ptr();
  size_t data_len = Packet::unpack3uint(&p) + PACKET_HEADER_SIZE;
  size_t packet_len =
      data_len > (size_t)row_packet_size ? data_len : row_packet_size;
  *new_packet = Backend::instance()->get_new_packet(packet_len);
  (*new_packet)->rewind();
  (*new_packet)->packdata(data, data_len);
  *(*new_packet)->wr_ptr() = '\0';
  delete *old_packet;
}

void pack_header(Packet *packet, size_t load_length) {
  packet->rewind();
  packet->pack3int(load_length);
  packet->packchar(0);
  packet->wr_ptr(load_length);
  *packet->wr_ptr() = '\0';
}

void check_lines_term_null(into_outfile_item *&into_outfile) {
  // if the LINES TERMINATED BY spectaror is NULL(""),
  // it will use the FIELDS TERMINATED BY replace it.
  if (into_outfile->lines_term_len == 0) {
    unsigned int length = into_outfile->fields_term_len;
    into_outfile->lines_term_len = length;
    for (unsigned int i = 0; i != length; i++) {
      into_outfile->lines_term[i] = into_outfile->fields_term[i];
    }
    into_outfile->lines_term[length] = '\0';
  }
}

ResultType get_result_type_from_column_type(MySQLColumnType col_type) {
  switch (col_type) {
    case MYSQL_TYPE_DECIMAL:
    case MYSQL_TYPE_TINY:
    case MYSQL_TYPE_SHORT:
    case MYSQL_TYPE_LONG:
    case MYSQL_TYPE_FLOAT:
    case MYSQL_TYPE_DOUBLE:
    case MYSQL_TYPE_LONGLONG:
    case MYSQL_TYPE_INT24:
    case MYSQL_TYPE_NEWDECIMAL:
      return RESULT_TYPE_NUM;
      break;

    case MYSQL_TYPE_DATE:
    case MYSQL_TYPE_TIME:
    case MYSQL_TYPE_DATETIME:
    case MYSQL_TYPE_VARCHAR:
    case MYSQL_TYPE_VAR_STRING:
    case MYSQL_TYPE_STRING:
      return RESULT_TYPE_STRING;
      break;

    default:
      throw UnSupportPartitionSQL("Column type in SelectNode is not support.");
  }
}

void rebuild_eof_with_has_more_flag(Packet *packet, MySQLDriver *driver) {
  if (driver->is_eof_packet(packet)) {
    MySQLEOFResponse eof(packet);
    eof.unpack();
    if (eof.has_more_result()) return;
    eof.set_has_more_result();
    // Packet *new_packet = new Packet(row_packet_size);
    eof.pack(packet);
    // delete tmp; *packet = new_packet;
  }
}

void rebuild_ok_with_has_more_flag(Packet *packet, MySQLDriver *driver) {
  if (driver->is_ok_packet(packet)) {
    MySQLOKResponse ok(packet);
    ok.unpack();
    if (ok.has_more_result()) return;
    ok.set_has_more_result();
    ok.pack(packet);
  }
}

void reset_packet_size(Packet *p, size_t len) {
  p->rewind();
  p->base();
  p->size(len);
}

void deal_with_str_column_value(string *str, CharsetType ctype) {
  size_t len = str->length();
  if (!len) return;

  int null_num = 0;
  for (size_t i = 0; i != len - 1; ++i) {
    if ((*str)[i + null_num] == '\0') {
      str->replace(i + null_num, 1, "\\0");
      ++null_num;
    }
  }

  if (ctype == CHARSET_TYPE_OTHER) {
    ctype = charset_type_maps[default_charset_type];
  }
  if (ctype == CHARSET_TYPE_GBK || ctype == CHARSET_TYPE_GB18030) {
    size_t i = 0;
    while (i < str->length()) {
      char c = (*str)[i];
      if ((unsigned char)c > 0x80 && (unsigned char)c < 0xFF) {
        ++i;
      } else {
        if (c == '\\' || c == '\'') {
          str->insert(i, 1, '\\');
          ++i;
        }
      }
      ++i;
    }
  } else {
    find_and_insert_str(str, "\\", "\\");
    find_and_insert_str(str, "'", "\\");
  }
}

void write_result_to_uservar(Session *session, string uservar_name,
                             const char *str, unsigned int length = 0,
                             bool is_number = false) {
  if (!str) {
    session->remove_user_var_by_name(uservar_name);
    LOG_DEBUG("Remove user variable [%s] cause it is NULL.\n",
              uservar_name.c_str());
    return;
  }

  string value(str, length);
  session->add_user_var_value(uservar_name, value, !is_number);
}

void print_warning_infos(Connection *conn) {
  if (!conn) return;
  vector<vector<string> > vec;
  try {
    conn->query_for_all_column("SHOW WARNINGS", &vec);
  } catch (...) {
    LOG_ERROR("Got exception when conn [%@] execute show warnings.\n", conn);
  }
  if (!vec.empty()) {
    string warning_info("SHOW WARNINGS;\n|Level|Code|Message|\n");
    vector<vector<string> >::iterator it = vec.begin();
    for (; it != vec.end(); it++) {
      vector<string>::iterator it1 = it->begin();
      for (; it1 != it->end(); it1++) {
        warning_info.append("|");
        warning_info.append(*it1);
      }
      warning_info.append("|\n");
    }
    LOG_INFO("%s", warning_info.c_str());
  }
}

void deal_with_var(Connection *conn, ExecutePlan *plan, MySQLDriver *driver) {
  Handler *handler = plan->handler;
  Session *session = plan->session;
  if (conn) {
    conn->reset();
    string var_sql = plan->statement->get_select_var_sql();
    if (var_sql.size() == 0) {
      return;
    }

    Packet *packet = Backend::instance()->get_new_packet(row_packet_size);
    Packet exec_packet;
    vector<string> *uservar_list = plan->statement->get_uservar_list();
    vector<string> *sessionvar_list = plan->statement->get_sessionvar_list();
    MySQLQueryRequest query(var_sql.c_str());
    query.set_sql_replace_char(
        plan->session->get_query_sql_replace_null_char());
    query.pack(&exec_packet);

    map<string, string> *conn_session_var_map = conn->get_session_var_map();
    map<string, string> *session_session_var_map =
        session->get_session_var_map();
    try {
      LOG_DEBUG("deal with var send sql [%s]\n", var_sql.c_str());
      handler->send_to_server(conn, &exec_packet);
      handler->receive_from_server(conn, packet);

      if (driver->is_error_packet(packet)) {
        LOG_ERROR("Internal select user variable sql got an error packet.\n");
        throw ErrorPacketException();
      }

      vector<bool> is_str_vec;
      vector<uint32_t> column_len;
      handler->receive_from_server(conn, packet);
      while (!driver->is_eof_packet(packet)) {
        if (driver->is_error_packet(packet)) {
          LOG_ERROR("Internal select user variable sql got an error packet.\n");
          throw ErrorPacketException();
        }
        MySQLColumnResponse column_response(packet);
        column_response.unpack();
        bool is_string = column_response.is_number() ? false : true;
        is_str_vec.push_back(is_string);
        unsigned int length = column_response.get_column_length();
        column_len.push_back(length);
        handler->receive_from_server(conn, packet);
      }

      handler->receive_from_server(conn, packet);
      while (!driver->is_eof_packet(packet)) {
        if (driver->is_error_packet(packet)) {
          LOG_ERROR("Internal select user variable sql got an error packet.\n");
          throw ErrorPacketException();
        }

        MySQLRowResponse row_response(packet);
        unsigned int user_num = uservar_list->size();
        unsigned int session_num = sessionvar_list->size();
        unsigned int fields_num = user_num + session_num;
        for (unsigned int i = 0; i != fields_num; i++) {
          if (i < user_num) {
            if (row_response.field_is_null(i)) {
              write_result_to_uservar(session, uservar_list->at(i), NULL);
            } else {
              uint64_t length;
              const char *str = row_response.get_str(i, &length);
              write_result_to_uservar(session, uservar_list->at(i), str, length,
                                      !is_str_vec[i]);
            }
          } else {
            string var_name = sessionvar_list->at(i - user_num);
            string var_value;
            if (row_response.field_is_null(i)) {
              var_value = "NULL";
              is_str_vec[i] = false;
            } else {
              uint64_t length;
              const char *str = row_response.get_str(i, &length);
              var_value = string(str, length);
            }
            if (!strcasecmp(var_name.c_str(), "CHARACTER_SET_CLIENT")) {
              int number = Backend::instance()->get_charset_number(var_value);
              if (number > 0)
                ((MySQLSession *)session)->set_client_charset(number);
            }
            if (is_str_vec[i]) {
              var_value = "'" + var_value + "'";
            }
            (*conn_session_var_map)[var_name] = var_value;
            (*session_session_var_map)[var_name] = var_value;
          }
        }
        session->set_session_var_map_md5(
            calculate_md5(session_session_var_map));
        conn->set_session_var_map_md5(calculate_md5(conn_session_var_map));
        handler->receive_from_server(conn, packet);
      }
      delete packet;
    } catch (Exception &e) {
      LOG_ERROR("Send select user variable to server got error!\n");
      delete packet;
      throw;
    }
  }
}

inline void handle_warnings_OK_and_eof_packet_inernal(
    MySQLDriver *driver, Packet *packet, Handler *handler, DataSpace *space,
    Connection *conn, bool skip_keep_conn) {
  if (!support_show_warning || skip_keep_conn ||
      (conn && conn->is_changed_user_conn()))  // do not handle keep conn for
                                               // changed_user conn
    return;
  uint16_t warnings = 0;
  if (driver->is_ok_packet(packet)) {
    MySQLOKResponse ok(packet);
    ok.unpack();
    warnings = ok.get_warnings();
  } else if (driver->is_eof_packet(packet)) {
    MySQLEOFResponse eof_response(packet);
    eof_response.unpack();
    warnings = eof_response.get_warnings();
  }
  if (!warnings) return;
  vector<Packet *> *warning_packet_list = NULL;
  uint64_t warning_packet_list_size = 0;
  bool has_add_warning_packet = false;
  Session *session = handler->get_session();
  LOG_DEBUG("session load warning count: [%Q]\n",
            session->get_load_warning_count());
  bool has_saved_too_many_warnings =
      session->get_load_warning_count() > MAX_LOAD_WARNING_PACKET_LIST_SIZE;
  try {
    if (!has_saved_too_many_warnings || support_log_warning_info)
      store_warning_packet(conn, handler, driver, &warning_packet_list,
                           has_add_warning_packet, warning_packet_list_size);
  } catch (std::exception &e) {
    LOG_ERROR("Getting warnings error: [%s]\n", e.what());
    return;
  }
  if (!has_add_warning_packet) return;
  if (support_log_warning_info) {
    MySQLResultSetHeaderResponse result_set(warning_packet_list->front());
    result_set.unpack();
    uint64_t columns_num = result_set.get_columns();
    vector<string> columns_name = vector<string>(0);
    vector<Packet *>::iterator it = warning_packet_list->begin() + 1;
    while (!driver->is_eof_packet(*it)) {
      // unpack FieldPacket
      MySQLFieldListColumnResponse field(*it);
      field.unpack();
      columns_name.push_back(string(field.get_column()));
      ++it;
    }
    ++it;
    string row_data = "query sql: ";
    row_data += handler->get_session()->get_query_sql();
    while (!driver->is_eof_packet(*it)) {
      // unpack RowPacket
      MySQLRowResponse row(*it);
      row.unpack();
      uint64_t field_len = 0;
      row_data += " [SHOW WARNING] ";
      for (unsigned int i = 0; i < columns_num; i++) {
        string cur_data = row.get_str(i, &field_len);
        cur_data = cur_data.substr(0, field_len);
        row_data += columns_name[i] + ": " + cur_data + ". ";
      }
      row_data += "\n";
      ++it;
    }
    LOG_INFO("%s", row_data.c_str());
  }
  if (!has_saved_too_many_warnings && warning_packet_list) {
    session->add_load_warning_packet_list(warning_packet_list,
                                          warning_packet_list_size);
  } else if (warning_packet_list) {
    for (vector<Packet *>::iterator it = warning_packet_list->begin();
         it != warning_packet_list->end(); ++it)
      delete (*it);
    delete warning_packet_list;
  }
  handler->get_session()->get_status()->item_inc(TIMES_WARNINGS_COUNT,
                                                 warnings);
  if (has_saved_too_many_warnings) {
    handler->get_session()->add_warning_dataspace(space, conn);
  }
  LOG_DEBUG("Get warning space %s%@\n", space->get_name(), space);
}

void handle_warnings_OK_and_eof_packet(ExecutePlan *plan, Packet *packet,
                                       Handler *handler, DataSpace *space,
                                       Connection *conn,
                                       bool skip_keep_conn = false) {
  if (plan == NULL) return;
  MySQLDriver *driver = (MySQLDriver *)plan->driver;
  handle_warnings_OK_and_eof_packet_inernal(driver, packet, handler, space,
                                            conn, skip_keep_conn);
}

inline void handle_warnings_OK_packet(Packet *packet, Handler *handler,
                                      DataSpace *space, Connection *conn,
                                      bool skip_keep_conn = false) {
  if (!support_show_warning || skip_keep_conn ||
      (conn && conn->is_changed_user_conn()))  // do not handle keep conn for
                                               // changed_user conn
    return;
  MySQLOKResponse ok(packet);
  ok.unpack();
  uint16_t warnings = ok.get_warnings();

  if (warnings) {
    handler->get_session()->get_status()->item_inc(TIMES_WARNINGS_COUNT,
                                                   warnings);
    handler->get_session()->add_warning_dataspace(space, conn);
    LOG_DEBUG("Get warning space %s%@\n", space->get_name(), space);
  }
}

/** Write the row data to the file.
 */
void MySQLIntoOutfileNode::write_into_outfile(Packet *packet,
                                              into_outfile_item *into_outfile,
                                              ofstream &file,
                                              spawn_param *param) {
  if (param && param->has_got_error()) {
    return;
  }
  string line_data;

  line_data.append(into_outfile->lines_start);

  char enclosed = into_outfile->fields_enclosed[0];
  char escaped = into_outfile->fields_escaped[0];

  MySQLRowResponse row(packet);
  unsigned int size = is_column_number.size();
  for (unsigned int i = 0; i != size; i++) {
    uint64_t row_len;
    const char *row_data = row.get_str(i, &row_len);
    bool is_null = row.field_is_null(i);
    /**
     * If the FIELDS ESCAPED BY is NULL(""), the NULL value will output as
     * "NULL", else the NULL values will output as the ESCAPED char + "N", like
     * the ESCAPED is "\\", output is "\N". But if the FIELDS TERNINATED BY is
     * NULL, it will output its length sapce.
     */
    if (is_null && !plan->statement->insert_select_via_fifo()) {
      if (into_outfile->fields_escaped_len == 0) {
        line_data.append("NULL");
      } else {
        line_data.append(into_outfile->fields_escaped);
        line_data.append("N");
      }

      if (i != size - 1) {
        line_data.append(into_outfile->fields_term);
      }

      continue;
    }

    /**
     * Process the field enclosed.
     * The output will add enclosed char before and after the column,
     * unless set the optionally and the column is a number.
     */
    bool enclosed_output_flag = false;
    if (into_outfile->fields_enclosed_len != 0 &&
        (!into_outfile->is_enclosed_optionally || !is_column_number[i])) {
      enclosed_output_flag = true;
    }

    if (enclosed_output_flag) {
      line_data.append(into_outfile->fields_enclosed);
    }

    char *escaped_str = NULL;
    if (row_len * 2 + 1 > DEFAULT_BUFFER_SIZE) {
      escaped_str = new char[row_len * 2 + 1];
    } else {
      escaped_str = row_buffer;
    }
    char *escaped_begin = escaped_str;
    const char *c = row_data;
    int index = 0;
    unsigned int row_index = 0;
    if (!is_column_number[i]) {
      // set the field escaped code, and the field is not a number
      while (row_index++ != row_len) {
        if (*c == '\0') {
          escaped_str[index++] = escaped;
          escaped_str[index++] = '0';
          c++;
        } else if (*c == escaped || *c == enclosed) {
          escaped_str[index++] = escaped;
          escaped_str[index++] = *c++;
        } else if (into_outfile->fields_enclosed_len == 0 &&
                   (*c == into_outfile->fields_term[0] ||
                    *c == into_outfile->lines_term[0])) {
          bool need_escaped = true;
          if (*c == into_outfile->fields_term[0] &&
              into_outfile->fields_term_len > 1) {
            if (row_len - row_index + 1 < into_outfile->fields_term_len)
              need_escaped = false;
            else if (strncmp((const char *)c,
                             (const char *)into_outfile->fields_term,
                             into_outfile->fields_term_len) != 0)
              need_escaped = false;
          } else if (*c == into_outfile->lines_term[0] &&
                     into_outfile->lines_term_len > 1) {
            if (row_len - row_index + 1 < into_outfile->lines_term_len)
              need_escaped = false;
            else if (strncmp((const char *)c,
                             (const char *)into_outfile->lines_term,
                             into_outfile->lines_term_len) != 0)
              need_escaped = false;
          }
          if (need_escaped) {
            escaped_str[index++] = escaped;
            escaped_str[index++] = *c++;
          } else {
            escaped_str[index++] = *c++;
          }
        } else {
          escaped_str[index++] = *c++;
        }
      }
      if (!is_null && row_len == 0 &&
          plan->statement->insert_select_via_fifo()) {  // for GOS specifically
        escaped_str[index++] = ' ';
      }
    } else {
      while (row_index++ != row_len) escaped_str[index++] = *c++;
    }
    escaped_str[index] = '\0';
    line_data.append(escaped_str);
    if (row_len * 2 + 1 > DEFAULT_BUFFER_SIZE) {
      delete[] escaped_begin;
    }

    if (enclosed_output_flag) line_data.append(into_outfile->fields_enclosed);

    if (i != size - 1) {
      line_data.append(into_outfile->fields_term);
    }
  }

  if (!is_local) {
    line_data.append(into_outfile->lines_term);
  } else {
    line_data.append(into_outfile->lines_term,
                     into_outfile->lines_term_len - 1);
  }
  if (param && param->has_got_error()) {
    return;
  }
  if (!is_local) {
    file << line_data.c_str();
  } else {
    MySQLRowResponse row_res(line_data);
    row_res.pack(packet);
  }
}

bool check_error_packet_found_rows(Packet *packet, MySQLSession *session,
                                   MySQLDriver *driver) {
  if (driver->is_error_packet(packet)) {
    LOG_ERROR("Found_rows get an error packet.\n");
    session->set_error_packet(packet);
    return true;
  }
  return false;
}

void found_rows(MySQLHandler *handler, MySQLDriver *driver, Connection *conn,
                MySQLSession *session) {
  Packet *packet = Backend::instance()->get_new_packet(row_packet_size);
  Packet exec_packet;

  conn->reset();
  MySQLQueryRequest query("SELECT FOUND_ROWS()");
  query.pack(&exec_packet);

  try {
    handler->send_to_server(conn, &exec_packet);
    handler->receive_from_server(conn, packet);

    if (check_error_packet_found_rows(packet, session, driver)) return;

    handler->receive_from_server(conn, packet);
    while (!driver->is_eof_packet(packet)) {
      if (check_error_packet_found_rows(packet, session, driver)) return;
      handler->receive_from_server(conn, packet);
    }

    handler->receive_from_server(conn, packet);
    while (!driver->is_eof_packet(packet)) {
      if (check_error_packet_found_rows(packet, session, driver)) return;
      MySQLRowResponse row(packet);
      session->add_found_rows(row.get_uint(0));
      handler->receive_from_server(conn, packet);
    }
  } catch (Exception &e) {
    LOG_ERROR("Send FOUND_ROWS() to server got error!\n");
    delete packet;
    throw;
  }
  delete packet;
}

void record_modify_server(ExecutePlan *plan, Session *session,
                          const char *server_name, unsigned int vid,
                          bool is_non_modified_conn) {
  if (session->check_for_transaction() &&
      !session->is_in_cluster_xa_transaction()) {
    stmt_type type = plan->statement->get_stmt_node()->type;
    switch (type) {
      case STMT_UPDATE:
      case STMT_DELETE:
      case STMT_INSERT:
      case STMT_REPLACE:
      case STMT_REPLACE_SELECT:
      case STMT_INSERT_SELECT:
      case STMT_LOAD: {
        if (!is_non_modified_conn)
          session->record_modify_server(server_name, vid);
        break;
      }
      default:
        break;
    }
  }
}

void record_xa_modify_sql(ExecutePlan *plan, Session *session,
                          DataSpace *dataspace, const char *sql,
                          bool is_non_modified_conn) {
  if (enable_xa_transaction &&
      session->get_session_option("close_session_xa").int_val == 0 &&
      session->check_for_transaction() &&
      !session->is_in_transaction_consistent()) {
    stmt_type type = plan->statement->get_stmt_node()->type;
    Driver *driver = Driver::get_driver();
    XA_helper *xa_helper = driver->get_xa_helper();
    switch (type) {
      case STMT_UPDATE:
      case STMT_DELETE:
      case STMT_INSERT:
      case STMT_REPLACE:
      case STMT_REPLACE_SELECT:
      case STMT_INSERT_SELECT: {
        if (!is_non_modified_conn)
          xa_helper->record_xa_redo_log(session, dataspace, sql);
        break;
      }
      case STMT_SET:
      case STMT_CHANGE_DB: {
        BackendServerVersion v =
            Backend::instance()->get_backend_server_version();
        if (!(v == MYSQL_VERSION_57 || v == MYSQL_VERSION_8)) {
          xa_helper->record_xa_redo_log(session, dataspace, sql, true);
        }
        break;
      }
      default:
        break;
    }
  }
}

void send_ok_packet_to_client(Handler *handler, uint64_t affected_rows,
                              uint16_t warnings) {
  Packet ok_packet;
  MySQLOKResponse ok(affected_rows, warnings);
  ok.pack(&ok_packet);
  handler->deal_autocommit_with_ok_eof_packet(&ok_packet);
  handler->record_affected_rows(&ok_packet);
  handler->send_to_client(&ok_packet);
}

void record_migrate_error_message(ExecutePlan *plan, Packet *packet, string msg,
                                  bool server_innodb_rollback_on_timeout) {
  if (plan->get_migrate_tool() && packet) {
    try {
      MySQLErrorResponse error(packet);
      error.unpack();
      char message[1000];
      sprintf(message, "%s %d (%s) %s.", msg.c_str(), error.get_error_code(),
              error.get_sqlstate(), error.get_error_message());
      plan->get_migrate_tool()->set_error_message(message);
      plan->get_migrate_tool()->add_select_error_not_rollback_info(
          error.get_error_code(), server_innodb_rollback_on_timeout);
    } catch (exception &e) {
      LOG_ERROR("record_migrate_error_message get exception [%s]\n", e.what());
    }
  }
}
void record_migrate_error_message(ExecutePlan *plan, string msg) {
  if (plan->get_migrate_tool()) {
    plan->get_migrate_tool()->set_error_message(msg);
  }
}

void init_column_types(list<Packet *> *field_packets,
                       vector<MySQLColumnType> &column_types,
                       unsigned int &column_num, bool *column_inited_flag) {
  if (column_inited_flag == NULL || *column_inited_flag == false) {
    list<Packet *>::iterator it_field;
    for (it_field = field_packets->begin(); it_field != field_packets->end();
         it_field++) {
      MySQLColumnResponse col_resp(*it_field);
      col_resp.unpack();
      column_types.push_back(col_resp.get_column_type());
    }

    column_num = field_packets->size();
    if (column_inited_flag) *column_inited_flag = true;
  }
}

void set_select_uservar_by_result(
    Packet *packet, vector<bool> &field_is_num_vec,
    vector<pair<unsigned int, string> > &uservar_vec,
    unsigned int select_field_num, Session *session) {
  MySQLRowResponse row_response(packet);
  unsigned int fields_num = field_is_num_vec.size();

  unsigned int j = 0;
  for (unsigned int i = 0; i != fields_num; i++) {
    if (j == uservar_vec.size()) break;
    pair<unsigned int, string> uservar_pair = uservar_vec[j];
    if (uservar_pair.first != i + select_field_num - fields_num) {
      continue;
    }

    string uservar_name = uservar_pair.second;
    if (row_response.field_is_null(i)) {
      write_result_to_uservar(session, uservar_name, NULL);
      j++;
      continue;
    }

    uint64_t length;
    const char *str = row_response.get_str(i, &length);
    write_result_to_uservar(session, uservar_name, str, length,
                            field_is_num_vec[i]);
    j++;
  }
}

void store_warning_packet(Connection *conn, Handler *handler,
                          MySQLDriver *driver,
                          vector<Packet *> **warning_packet_list,
                          bool &has_add_warning_packet,
                          uint64_t &warning_packet_list_size) {
  Packet exec_packet;
  MySQLQueryRequest show_warning_query("SHOW WARNINGS");
  show_warning_query.pack(&exec_packet);
  conn->reset();
  handler->send_to_server(conn, &exec_packet);
  // receive header
  Packet *packet = NULL;
  packet = Backend::instance()->get_new_packet();
  try {
    handler->receive_from_server(conn, packet);
    if (driver->is_error_packet(packet)) {
      MySQLErrorResponse error(packet);
      error.unpack();
      LOG_ERROR(
          "when try to fetch show warnings info, get an error packet, %d (%s) "
          "%s.\n",
          packet, error.get_error_code(), error.get_sqlstate(),
          error.get_error_message());
      throw Error("when try to fetch show warnings info, get error packet");
    }
    if (!has_add_warning_packet) {
      *warning_packet_list = NULL;
      (*warning_packet_list) = new vector<Packet *>();
      (*warning_packet_list)->push_back(packet);
      packet = NULL;
      packet = Backend::instance()->get_new_packet();
    }
    // receive column packets
    handler->receive_from_server(conn, packet);
    while (!driver->is_eof_packet(packet)) {
      if (driver->is_error_packet(packet)) {
        MySQLErrorResponse error(packet);
        error.unpack();
        LOG_ERROR(
            "when try to fetch show warnings info, get an error packet, %d "
            "(%s) "
            "%s.\n",
            packet, error.get_error_code(), error.get_sqlstate(),
            error.get_error_message());
        throw Error("when try to fetch show warnings info, get error packet");
      }
      if (!has_add_warning_packet) {
        (*warning_packet_list)->push_back(packet);
        packet = NULL;
        packet = Backend::instance()->get_new_packet();
      }
      handler->receive_from_server(conn, packet);
    }
    if (!has_add_warning_packet) {
      (*warning_packet_list)->push_back(packet);
      packet = NULL;
      packet = Backend::instance()->get_new_packet();
      has_add_warning_packet = true;
    } else {
      // remove the previous tailed eof packet in warning_packet_list, then
      // append more warning packet
      Packet *tmp_pkt = (*warning_packet_list)->back();
      (*warning_packet_list)->pop_back();
      delete tmp_pkt;
    }
    // receive row packets
    handler->receive_from_server(conn, packet);
    while (!driver->is_eof_packet(packet)) {
      if (driver->is_error_packet(packet)) {
        MySQLErrorResponse error(packet);
        error.unpack();
        LOG_ERROR(
            "when try to fetch show warnings info, get an error packet, %d "
            "(%s) "
            "%s.\n",
            packet, error.get_error_code(), error.get_sqlstate(),
            error.get_error_message());
        throw Error("when try to fetch show warnings info, get error packet");
      }
      if (load_data_quick_error > 0 &&
          handler->get_session()->get_top_stmt()->get_stmt_node()->type ==
              STMT_LOAD) {
        const char *field_data = NULL;
        uint64_t row_len = 0;
        MySQLRowResponse response(packet);
        // Level, Code, Message
        field_data = response.get_str(0, &row_len);
        string level = response.field_is_null(0) ? string("")
                                                 : string(field_data, row_len);
        field_data = response.get_str(1, &row_len);
        string code = response.field_is_null(1) ? string("")
                                                : string(field_data, row_len);
        field_data = response.get_str(2, &row_len);
        string message = response.field_is_null(2)
                             ? string("")
                             : string(field_data, row_len);
        LOG_ERROR(
            "got error when load data: Level:[%s], Code:[%s], Message:[%s]\n",
            level.c_str(), code.c_str(), message.c_str());
        LOG_ERROR(
            "load_data_quick_error is enabled, cancel current load data task, "
            "this will lead client broken.\n");
        throw Error(
            "got error when load data, load_data_quick_error is enabled, "
            "cancel "
            "current load data task, this will lead client broken, see log for "
            "more infomation");
      }
#ifdef DEBUG
      LOG_DEBUG("store one warning packet during load data.\n");
#endif
      (*warning_packet_list)->push_back(packet);
      packet = NULL;
      warning_packet_list_size++;
      packet = Backend::instance()->get_new_packet();
      handler->receive_from_server(conn, packet);
    }
#ifndef DBSCALE_TEST_DISABLE
    dbscale_test_info *test_info =
        handler->get_session()->get_dbscale_test_info();
    if (test_info->test_case_name == "show warnings" &&
        test_info->test_case_operation == "test memory leak") {
      throw ExecuteNodeError("Show warnings Fake Error!");
    }
#endif
    (*warning_packet_list)->push_back(packet);
  } catch (...) {
    delete packet;
    if (*warning_packet_list) {
      vector<Packet *>::iterator it = (*warning_packet_list)->begin();
      for (; it != (*warning_packet_list)->end(); ++it) {
        delete *it;
      }
      delete *warning_packet_list;
      *warning_packet_list = NULL;
    }
    throw;
  }
}

size_t check_first_row_complete(Packet *packet, string field_terminate,
                                string line_terminate, bool has_field_enclose,
                                char field_enclose, char field_escape,
                                unsigned int table_fields_num) {
  ACE_UNUSED_ARG(table_fields_num);
  const char *pos = packet->base() + PACKET_HEADER_SIZE;
  const char *end = packet->base() + packet->length();
  const char *start = pos;
#ifdef DEBUG
  unsigned int fields_count = 0;
#endif
  bool is_char_escaped = false;
  bool need_enclose = false;
  if (has_field_enclose && field_enclose == *start) need_enclose = true;
  bool enclose_field_end = false;
  int field_term_len = field_terminate.length();
  int line_term_len = line_terminate.length();
  while (pos != end) {
    if (is_char_escaped) {
      is_char_escaped = false;
      pos++;
      continue;
    }

    if (*pos == line_terminate[0]) {
      if (line_term_len == 1) {
        break;
      } else if (end - pos < line_term_len) {
        pos = end;
        break;
      } else if (line_terminate == string(pos, line_term_len)) {
        pos += line_term_len - 1;
        break;
      }
    }

    if (*pos == field_escape) {
      is_char_escaped = true;
      pos++;
      continue;
    }

    if (need_enclose && !enclose_field_end && *pos == field_enclose &&
        pos != start) {
      enclose_field_end = true;
      pos++;
      continue;
    }

    if (enclose_field_end && *pos == field_enclose) {
    } else if (*pos == field_terminate[0]) {
      if (need_enclose && !enclose_field_end) {
        pos++;
        continue;
      }
      if (end - pos < field_term_len) {
        pos++;
        continue;
      }
      if (field_term_len != 1 &&
          field_terminate != string(pos, field_term_len)) {
        pos++;
        continue;
      } else {
        pos += field_term_len - 1;
      }
#ifdef DEBUG
      fields_count++;
#endif
      start = pos + 1;
      if (has_field_enclose && *start == field_enclose) {
        need_enclose = true;
        enclose_field_end = false;
      } else {
        need_enclose = false;
      }
    }
    pos++;
    enclose_field_end = false;
  }
  if (pos == end) {
    /*This packet does not reach the end of packet, so we need to read one
     * more packet.*/
    return packet->length();
  }

#ifdef DEBUG
  if (table_fields_num) ACE_ASSERT(fields_count <= table_fields_num);
#endif
  // TODO: return 0, if it contains the complete row in issue #3675
  /*
  if (*pos == line_terminate && fields_count == table_fields_num - 1)
    return 0;
  */
  return pos - (packet->base() + PACKET_HEADER_SIZE) + 1;
}

void divide_packet_by_first_row(Packet *packet, size_t first_row_len,
                                Packet **first_row_packet,
                                Packet **rest_row_packet) {
  Packet *pf = Backend::instance()->get_new_packet(first_row_len +
                                                   PACKET_HEADER_SIZE + 1);
  memcpy(pf->base() + PACKET_HEADER_SIZE, packet->base() + PACKET_HEADER_SIZE,
         first_row_len);
  char *p = packet->base();
  size_t len = Packet::unpack3uint(&p);
  Packet *pr = Backend::instance()->get_new_packet(len - first_row_len +
                                                   PACKET_HEADER_SIZE + 1);
  memcpy(pr->base() + PACKET_HEADER_SIZE,
         packet->base() + PACKET_HEADER_SIZE + first_row_len,
         len - first_row_len);
  *first_row_packet = pf;
  *rest_row_packet = pr;

  pf->rewind();
  pr->rewind();

  pack_header(pf, first_row_len);
  pack_header(pr, len - first_row_len);

#ifdef DEBUG
  LOG_DEBUG(
      "Find a divided packet with first incomplete row pos %d, reset packet "
      "len %d for pacekt %@.\n",
      first_row_len, len - first_row_len, packet);
#endif
  if (len == first_row_len) {
    LOG_DEBUG("Find a one row packet, should not divide it.\n");
    delete pf;
    delete pr;
    *first_row_packet = NULL;
    *rest_row_packet = NULL;
  }
}

void pack_packet(Packet *packet, string data, unsigned int len) {
  packet->size(len + PACKET_HEADER_SIZE + 1);
  try {
    memcpy(packet->base() + PACKET_HEADER_SIZE, data.c_str(), len);
  } catch (...) {
    LOG_ERROR("pack_packet get exception for pack_packet.\n");
    throw;
  }
  pack_header(packet, len);
}

void redo_load(Connection *load_conn, string sql, Handler *handler,
               MySQLDriver *driver, uint64_t &affected_row_count,
               uint64_t &warning_count, uint64_t &warning_packet_list_size,
               vector<Packet *> **warning_packet_list,
               bool &has_add_warning_packet) {
  LOG_DEBUG("redo_load\n");
  // send empty to tell server load end
  TimeValue timeout =
      TimeValue(redo_load_timeout > 0 ? redo_load_timeout : UINT_MAX, 0);
  Packet *packet = Backend::instance()->get_new_packet();
  pack_packet(packet, "", 0);
  handler->send_to_server(load_conn, packet);
  handler->receive_from_server(load_conn, packet, &timeout);
  if (driver->is_error_packet(packet)) {
    MySQLErrorResponse error(packet);
    error.unpack();
    LOG_ERROR("redo_load get an error packet %d (%s) %s.\n",
              error.get_error_code(), error.get_sqlstate(),
              error.get_error_message());
    char err_msg[256];
    sprintf(err_msg, "redo_load get an error packet, %d (%s) %s.\n",
            error.get_error_code(), error.get_sqlstate(),
            error.get_error_message());

    if (packet) {
      delete packet;
    }
    throw Error(err_msg);
  }

  MySQLOKResponse ok(packet);
  ok.unpack();
  uint64_t warnings = ok.get_warnings();
  uint64_t affected_rows = ok.get_affected_rows();
  affected_row_count += affected_rows;
  warning_count += warnings;
  if (support_show_warning &&
      (warning_packet_list_size < MAX_LOAD_WARNING_PACKET_LIST_SIZE) &&
      warnings)
    store_warning_packet(load_conn, handler, driver, warning_packet_list,
                         has_add_warning_packet, warning_packet_list_size);
  load_conn->reset();

  // do load again
  MySQLQueryRequest query(sql.c_str());
  query.set_sql_replace_char(
      handler->get_session()->get_query_sql_replace_null_char());
  Packet exec_query;
  query.pack(&exec_query);
  handler->send_to_server(load_conn, &exec_query);
  handler->receive_from_server(load_conn, packet, &timeout);
  if (driver->is_error_packet(packet)) {
    MySQLErrorResponse error(packet);
    error.unpack();
    LOG_ERROR("redo_load get an error packet %d (%s) %s.\n",
              error.get_error_code(), error.get_sqlstate(),
              error.get_error_message());
    char err_msg[256];
    sprintf(err_msg, "redo_load get an error packet, %d (%s) %s.\n",
            error.get_error_code(), error.get_sqlstate(),
            error.get_error_message());

    if (packet) {
      delete packet;
    }
    throw Error(err_msg);
  }
  if (packet) {
    delete packet;
  }
}

/* class MySQLExecutePlan */

MySQLExecutePlan::MySQLExecutePlan(Statement *statement, Session *session,
                                   Driver *driver, Handler *handler)
    : ExecutePlan(statement, session, driver, handler) {}

ExecuteNode *MySQLExecutePlan::do_get_fetch_node(DataSpace *dataspace,
                                                 const char *sql) {
  return new MySQLFetchNode(this, dataspace, sql);
}
ExecuteNode *MySQLExecutePlan::do_get_navicat_profile_sql_node() {
  return new MySQLNavicateProfileSqlNode(this);
}

#ifndef DBSCALE_DISABLE_SPARK
ExecuteNode *MySQLExecutePlan::do_get_spark_node(SparkConfigParameter config,
                                                 bool is_insert) {
  return new MySQLSparkNode(this, config, is_insert);
}
#endif

ExecuteNode *MySQLExecutePlan::do_get_send_node() {
  return new MySQLSendNode(this);
}

ExecuteNode *MySQLExecutePlan::do_get_dispatch_packet_node(TransferRule *rule) {
  return new MySQLDispatchPacketNode(this, rule);
}

ExecuteNode *MySQLExecutePlan::do_get_into_outfile_node() {
  return new MySQLIntoOutfileNode(this);
}

ExecuteNode *MySQLExecutePlan::do_get_modify_limit_node(
    record_scan *rs, PartitionedTable *table, vector<unsigned int> &par_ids,
    unsigned int limit, string &sql) {
  return new MySQLModifyLimitNode(this, rs, table, par_ids, limit, sql);
}

ExecuteNode *MySQLExecutePlan::do_get_select_into_node() {
  return new MySQLSelectIntoNode(this);
}

ExecuteNode *MySQLExecutePlan::do_get_sort_node(list<SortDesc> *sort_desc) {
  return new MySQLSortNode(this, sort_desc);
}

ExecuteNode *MySQLExecutePlan::do_get_project_node(unsigned int skip_columns) {
  return new MySQLProjectNode(this, skip_columns);
}

ExecuteNode *MySQLExecutePlan::do_get_aggr_node(
    list<AggregateDesc> &aggregate_desc) {
  return new MySQLAggregateNode(this, aggregate_desc);
}

ExecuteNode *MySQLExecutePlan::do_get_group_node(
    list<SortDesc> *group_desc, list<AggregateDesc> &aggregate_desc) {
  ExecuteNode *node = new MySQLGroupNode(this, group_desc, aggregate_desc);
#ifdef DEBUG
  LOG_DEBUG("in MySQLExecutePlan::do_get_group_node(), get node %@\n", node);
#endif
  return node;
}

ExecuteNode *MySQLExecutePlan::do_get_dbscale_wise_group_node(
    list<SortDesc> *group_desc, list<AggregateDesc> &aggregate_desc) {
  return new MySQLWiseGroupNode(this, group_desc, aggregate_desc);
}

ExecuteNode *MySQLExecutePlan::do_get_dbscale_pages_node(
    list<SortDesc> *group_desc, list<AggregateDesc> &aggregate_desc,
    int page_size) {
  return new MySQLPagesNode(this, group_desc, aggregate_desc, page_size);
}

ExecuteNode *MySQLExecutePlan::do_get_single_sort_node(
    list<SortDesc> *sort_desc) {
  return new MySQLSingleSortNode(this, sort_desc);
}

ExecuteNode *MySQLExecutePlan::do_get_direct_execute_node(DataSpace *dataspace,
                                                          const char *sql) {
  return new MySQLDirectExecuteNode(this, dataspace, sql);
}

ExecuteNode *MySQLExecutePlan::do_get_show_warning_node() {
  return new MySQLShowWarningNode(this);
}

ExecuteNode *MySQLExecutePlan::do_get_show_load_warning_node() {
  return new MySQLShowLoadWarningNode(this);
}

ExecuteNode *MySQLExecutePlan::do_get_query_one_column_node(
    DataSpace *dataspace, const char *sql, bool only_one_row) {
  return new MySQLQueryForOneColumnNode(this, dataspace, sql, only_one_row);
}
ExecuteNode *MySQLExecutePlan::do_get_query_mul_column_node(
    DataSpace *dataspace, const char *sql) {
  return new MySQLQueryForMulColumnNode(this, dataspace, sql);
}
ExecuteNode *MySQLExecutePlan::do_get_query_one_column_aggr_node(
    DataSpace *dataspace, const char *sql, bool get_min) {
  return new MySQLQueryForOneColumnAggrNode(this, dataspace, sql, get_min);
}
ExecuteNode *MySQLExecutePlan::do_get_query_exists_node(DataSpace *dataspace,
                                                        const char *sql) {
  return new MySQLQueryExistsNode(this, dataspace, sql);
}

ExecuteNode *MySQLExecutePlan::do_get_transaction_unlock_node(
    const char *sql, bool is_send_to_client) {
  return new MySQLTransactionUNLockNode(this, sql, is_send_to_client);
}

ExecuteNode *MySQLExecutePlan::do_get_xatransaction_node(
    const char *sql, bool is_send_to_client) {
  return new MySQLXATransactionNode(this, sql, is_send_to_client);
}

ExecuteNode *MySQLExecutePlan::do_get_cluster_xatransaction_node() {
  return new MySQLClusterXATransactionNode(this);
}
ExecuteNode *MySQLExecutePlan::do_get_avg_node(list<AvgDesc> &avg_list) {
  return new MySQLAvgNode(this, avg_list);
}
ExecuteNode *MySQLExecutePlan::do_get_lock_node(
    map<DataSpace *, list<lock_table_item *> *> *lock_table_list) {
  return new MySQLLockNode(this, lock_table_list);
}

ExecuteNode *MySQLExecutePlan::do_get_migrate_node() {
  return new MySQLMigrateNode(this);
}
ExecuteNode *MySQLExecutePlan::do_get_limit_node(long offset, long num) {
  return new MySQLLimitNode(this, offset, num);
}

ExecuteNode *MySQLExecutePlan::do_get_ok_node() {
  return new MySQLOKNode(this);
}

ExecuteNode *MySQLExecutePlan::do_get_drop_mul_table_node() {
  return new MySQLDropMulTableNode(this);
}

ExecuteNode *MySQLExecutePlan::do_get_ok_merge_node() {
  return new MySQLOKMergeNode(this);
}

ExecuteNode *MySQLExecutePlan::do_get_modify_node(DataSpace *dataspace,
                                                  const char *sql,
                                                  bool re_parse_shard) {
  MySQLModifyNode *modify_node = new MySQLModifyNode(this, dataspace);
  if (sql) {
    if (re_parse_shard) {
      modify_node->add_sql_during_exec(sql);
    } else {
      modify_node->add_sql(sql);
    }
    modify_node->add_sql("");
  }
  return modify_node;
}

ExecuteNode *MySQLExecutePlan::do_get_modify_select_node(
    const char *modify_sql, vector<string *> *columns, bool can_quick,
    vector<ExecuteNode *> *nodes, bool is_replace_set_value) {
  MySQLModifySelectNode *node = new MySQLModifySelectNode(
      this, modify_sql, columns, nodes, can_quick, is_replace_set_value);
  return node;
}

ExecuteNode *MySQLExecutePlan::do_get_insert_select_node(
    const char *modify_sql, vector<ExecuteNode *> *nodes) {
  MySQLInsertSelectNode *node =
      new MySQLInsertSelectNode(this, modify_sql, nodes);
  return node;
}

ExecuteNode *MySQLExecutePlan::do_get_par_modify_select_node(
    const char *modify_sql, PartitionedTable *par_table,
    PartitionMethod *method, vector<string *> *columns, bool can_quick,
    vector<ExecuteNode *> *nodes) {
  MySQLPartitionModifySelectNode *node = new MySQLPartitionModifySelectNode(
      this, modify_sql, nodes, par_table, method, columns, can_quick);
  return node;
}
ExecuteNode *MySQLExecutePlan::do_get_par_insert_select_node(
    const char *modify_sql, PartitionedTable *par_table,
    PartitionMethod *method, vector<unsigned int> &key_pos,
    vector<ExecuteNode *> *nodes, const char *schema_name,
    const char *table_name, bool is_duplicated) {
  MySQLPartitionInsertSelectNode *node = new MySQLPartitionInsertSelectNode(
      this, modify_sql, nodes, par_table, method, key_pos, schema_name,
      table_name, is_duplicated);
  return node;
}

ExecuteNode *MySQLExecutePlan::do_get_load_local_node(DataSpace *dataspace,
                                                      const char *sql) {
  return new MySQLLoadLocalNode(this, dataspace, sql);
}

ExecuteNode *MySQLExecutePlan::do_get_load_local_external_node(
    DataSpace *dataspace, DataServer *dataserver, const char *sql) {
  return new MySQLLoadLocalExternal(this, dataspace, dataserver, sql);
}

ExecuteNode *MySQLExecutePlan::do_get_load_data_infile_external_node(
    DataSpace *dataspace, DataServer *dataserver) {
  return new MySQLLoadDataInfileExternal(this, dataspace, dataserver);
}

ExecuteNode *MySQLExecutePlan::do_get_kill_node(int cluster_id, uint32_t kid) {
  return new MySQLKillNode(this, cluster_id, kid);
}

ExecuteNode *MySQLExecutePlan::do_get_load_local_part_table_node(
    PartitionedTable *dataspace, const char *sql, const char *schema_name,
    const char *table_name) {
  return new MySQLLoadLocalPartTableNode(this, dataspace, sql, schema_name,
                                         table_name);
}
ExecuteNode *MySQLExecutePlan::do_get_load_data_infile_part_table_node(
    PartitionedTable *dataspace, const char *sql, const char *schema_name,
    const char *table_name) {
  return new MySQLLoadDataInfilePartTableNode(this, dataspace, sql, schema_name,
                                              table_name);
}

ExecuteNode *MySQLExecutePlan::do_get_load_data_infile_node(
    DataSpace *dataspace, const char *sql) {
  return new MySQLLoadDataInfileNode(this, dataspace, sql);
}

ExecuteNode *MySQLExecutePlan::do_get_load_select_node(const char *schema_name,
                                                       const char *table_name) {
  return new MySQLLoadSelectNode(this, schema_name, table_name);
}

ExecuteNode *MySQLExecutePlan::do_get_load_select_partition_node(
    const char *schema_name, const char *table_name) {
  return new MySQLLoadSelectPartitionNode(this, schema_name, table_name);
}

ExecuteNode *MySQLExecutePlan::do_get_distinct_node(list<int> column_indexes) {
  return new MySQLDistinctNode(this, column_indexes);
}
ExecuteNode *MySQLExecutePlan::do_get_rows_node(
    list<list<string> *> *row_list) {
  return new MySQLRowsNode(this, row_list);
}
ExecuteNode *MySQLExecutePlan::do_get_dbscale_cluster_shutdown_node(
    int cluster_id) {
  return new MySQLDBScaleClusterShutdownNode(this, cluster_id);
}
ExecuteNode *MySQLExecutePlan::do_get_dbscale_request_cluster_id_node() {
  return new MySQLDBScaleRequestClusterIdNode(this);
}
ExecuteNode *
MySQLExecutePlan::do_get_dbscale_request_all_cluster_inc_info_node() {
  return new MySQLDBScaleRequestAllClusterIncInfoNode(this);
}
ExecuteNode *MySQLExecutePlan::do_get_dbscale_request_cluster_info_node() {
  return new MySQLDBScaleRequestClusterInfoNode(this);
}
ExecuteNode *MySQLExecutePlan::do_get_dbscale_request_cluster_user_status_node(
    const char *id, bool only_show_running, bool show_status_count) {
  return new MySQLDBScaleRequestUserStatusNode(this, id, only_show_running,
                                               show_status_count);
}

ExecuteNode *MySQLExecutePlan::do_get_dbscale_clean_temp_table_cache_node() {
  return new MySQLDBScaleCleanTempTableCacheNode(this);
}

ExecuteNode *MySQLExecutePlan::do_get_dbscale_request_node_info_node() {
  return new MySQLDBScaleRequestNodeInfoNode(this);
}
ExecuteNode *MySQLExecutePlan::do_get_dbscale_request_cluster_inc_info_node(
    PartitionedTable *space, const char *schema_name, const char *table_name) {
  return new MySQLDBScaleRequestClusterIncInfoNode(this, space, schema_name,
                                                   table_name);
}
ExecuteNode *MySQLExecutePlan::do_get_regex_filter_node(
    enum FilterFlag filter_way, int column_index, list<const char *> *pattern) {
  return new MySQLRegexFilterNode(this, filter_way, column_index, pattern);
}
ExecuteNode *MySQLExecutePlan::do_get_expr_filter_node(Expression *expr) {
  return new MySQLExprFilterNode(this, expr);
}
ExecuteNode *MySQLExecutePlan::do_get_expr_calculate_node(
    list<SelectExprDesc> &select_expr_list) {
  return new MySQLExprCalculateNode(this, select_expr_list);
}
ExecuteNode *MySQLExecutePlan::do_get_avg_show_table_status_node() {
  return new MySQLAvgShowTableStatusNode(this);
}

ExecuteNode *MySQLExecutePlan::do_get_show_data_source_node(
    list<const char *> &names, bool need_show_weight) {
  return new MySQLDBScaleShowDataSourceNode(this, names, need_show_weight);
}
ExecuteNode *MySQLExecutePlan::do_get_dynamic_configuration_node() {
  return new MySQLDynamicConfigurationNode(this);
}
ExecuteNode *MySQLExecutePlan::do_get_rep_strategy_node() {
  return new MySQLRepStrategyNode(this);
}
ExecuteNode *MySQLExecutePlan::do_get_set_server_weight_node() {
  return new MySQLDynamicSetServerWeightNode(this);
}
ExecuteNode *MySQLExecutePlan::do_get_show_option_node() {
  return new MySQLDBScaleShowOptionNode(this);
}
ExecuteNode *MySQLExecutePlan::do_get_show_dynamic_option_node() {
  return new MySQLDBScaleShowDynamicOptionNode(this);
}
ExecuteNode *MySQLExecutePlan::do_get_change_startup_config_node() {
  return new MySQLChangeStartupConfigNode(this);
}
ExecuteNode *MySQLExecutePlan::do_get_show_changed_startup_config_node() {
  return new MySQLShowChangedStartupConfigNode(this);
}
ExecuteNode *MySQLExecutePlan::do_get_dynamic_add_data_server_node(
    dynamic_add_data_server_op_node *dynamic_add_data_server_oper) {
  return new MySQLDynamicAddDataServerNode(this, dynamic_add_data_server_oper);
}
ExecuteNode *MySQLExecutePlan::do_get_dynamic_add_data_source_node(
    dynamic_add_data_source_op_node *dynamic_add_data_source_oper,
    DataSourceType type) {
  return new MySQLDynamicAddDataSourceNode(this, dynamic_add_data_source_oper,
                                           type);
}
ExecuteNode *MySQLExecutePlan::do_get_dynamic_add_data_space_node(
    dynamic_add_data_space_op_node *dynamic_add_data_space_oper) {
  return new MySQLDynamicAddDataSpaceNode(this, dynamic_add_data_space_oper);
}
ExecuteNode *MySQLExecutePlan::do_get_set_schema_acl_node(
    set_schema_acl_op_node *set_schema_acl_oper) {
  return new MySQLSetSchemaACLNode(this, set_schema_acl_oper);
}
ExecuteNode *MySQLExecutePlan::do_get_set_user_not_allow_operation_time_node(
    set_user_not_allow_operation_time_node *oper) {
  return new MySQLSetUserAllowOperationTimeNode(this, oper);
}
ExecuteNode *MySQLExecutePlan::do_get_reload_user_not_allow_operation_time_node(
    string user_name) {
  return new MySQLReloadUserAllowOperationTimeNode(this, user_name);
}
ExecuteNode *MySQLExecutePlan::do_get_show_user_not_allow_operation_time_node(
    string user_name) {
  return new MySQLShowUserNotAllowOperationTimeNode(this, user_name);
}
ExecuteNode *MySQLExecutePlan::do_get_set_table_acl_node(
    set_table_acl_op_node *set_table_acl_oper) {
  return new MySQLSetTableACLNode(this, set_table_acl_oper);
}
ExecuteNode *MySQLExecutePlan::do_get_dynamic_add_slave_node(
    dynamic_add_slave_op_node *dynamic_add_slave_oper) {
  return new MySQLDynamicAddSlaveNode(this, dynamic_add_slave_oper);
}
ExecuteNode *MySQLExecutePlan::do_get_reset_tmp_table_node() {
  return new MySQLResetTmpTableNode(this);
}
ExecuteNode *MySQLExecutePlan::do_get_reload_function_type_node() {
  return new MySQLLoadFuncTypeNode(this);
}
ExecuteNode *MySQLExecutePlan::do_get_shutdown_node() {
  return new MySQLShutDownNode(this);
}
ExecuteNode *MySQLExecutePlan::do_get_dynamic_change_master_node(
    dynamic_change_master_op_node *dynamic_change_master_oper) {
  return new MySQLDynamicChangeMasterNode(this, dynamic_change_master_oper);
}
ExecuteNode *
MySQLExecutePlan::do_get_dynamic_change_multiple_master_active_node(
    dynamic_change_multiple_master_active_op_node
        *dynamic_change_multiple_master_active_oper) {
  return new MySQLDynamicChangeMultipleMasterActiveNode(
      this, dynamic_change_multiple_master_active_oper);
}
ExecuteNode *MySQLExecutePlan::do_get_dynamic_change_dataserver_ssh_node(
    const char *server_name, const char *username, const char *pwd, int port) {
  return new MySQLDynamicChangeDataServerSShNode(this, server_name, username,
                                                 pwd, port);
}
ExecuteNode *MySQLExecutePlan::do_get_dynamic_remove_slave_node(
    dynamic_remove_slave_op_node *dynamic_remove_slave_oper) {
  return new MySQLDynamicRemoveSlaveNode(this, dynamic_remove_slave_oper);
}
ExecuteNode *MySQLExecutePlan::do_get_dynamic_remove_schema_node(
    const char *schema_name, bool is_force) {
  return new MySQLDynamicRemoveSchemaNode(this, schema_name, is_force);
}
ExecuteNode *MySQLExecutePlan::do_get_dynamic_remove_table_node(
    const char *table_name, bool is_force) {
  return new MySQLDynamicRemoveTableNode(this, table_name, is_force);
}
ExecuteNode *MySQLExecutePlan::do_get_dynamic_change_table_scheme_node(
    const char *table_name, const char *scheme_name) {
  return new MySQLDynamicChangeTableSchemeNode(this, table_name, scheme_name);
}
ExecuteNode *MySQLExecutePlan::do_get_dynamic_remove_node(const char *name) {
  return new MySQLDynamicRemoveOPNode(this, name);
}
ExecuteNode *MySQLExecutePlan::do_get_dbscale_help_node(const char *name) {
  return new MySQLDBScaleHelpNode(this, name);
}
ExecuteNode *MySQLExecutePlan::do_get_dbscale_show_audit_user_list_node() {
  return new MySQLDBScaleShowAuditUserListNode(this);
}
ExecuteNode *MySQLExecutePlan::do_get_dbscale_show_slow_sql_top_n_node() {
  return new MySQLDBScaleShowSlowSqlTopNNode(this);
}
ExecuteNode *MySQLExecutePlan::do_get_dbscale_request_slow_sql_top_n_node() {
  return new MySQLDBScaleRequestSlowSqlTopNNode(this);
}
ExecuteNode *MySQLExecutePlan::do_get_dbscale_show_join_node(const char *name) {
  return new MySQLDBScaleShowJoinNode(this, name);
}
ExecuteNode *MySQLExecutePlan::do_get_dbscale_show_shard_partition_node(
    const char *name) {
  return new MySQLDBScaleShowShardPartitionNode(this, name);
}
ExecuteNode *MySQLExecutePlan::do_get_dbscale_show_rebalance_work_load_node(
    const char *name, list<string> sources, const char *schema_name,
    int is_remove) {
  return new MySQLDBScaleShowRebalanceWorkLoadNode(this, name, sources,
                                                   schema_name, is_remove);
}
ExecuteNode *MySQLExecutePlan::do_get_show_user_memory_status_node() {
  return new MySQLDBScaleShowUserMemoryStatusNode(this);
}
ExecuteNode *MySQLExecutePlan::do_get_show_user_status_node(
    const char *user_id, const char *user_name, bool only_show_running,
    bool instance, bool show_status_count) {
  return new MySQLDBScaleShowUserStatusNode(
      this, user_id, user_name, only_show_running, instance, show_status_count);
}
ExecuteNode *MySQLExecutePlan::do_get_show_user_processlist_node(
    const char *cluster_id, const char *user_id, int local) {
  return new MySQLDBScaleShowUserProcesslistNode(this, cluster_id, user_id,
                                                 local);
}
ExecuteNode *MySQLExecutePlan::do_get_show_session_id_node(
    const char *server_name, int connection_id) {
  return new MySQLDBScaleShowSessionIdNode(this, server_name, connection_id);
}
ExecuteNode *MySQLExecutePlan::do_get_backend_server_execute_node(
    const char *stmt_sql) {
  return new MySQLDBScaleBackendServerExecuteNode(this, stmt_sql);
}
ExecuteNode *MySQLExecutePlan::do_get_execute_on_all_masterserver_execute_node(
    const char *stmt_sql) {
  return new MySQLDBScaleExecuteOnAllMasterserverExecuteNode(this, stmt_sql);
}
ExecuteNode *MySQLExecutePlan::do_get_show_table_location_node(
    const char *schema_name, const char *table_name) {
  return new MySQLDBScaleShowTableLocationNode(this, schema_name, table_name);
}
ExecuteNode *MySQLExecutePlan::do_get_dbscale_erase_auth_info_node(
    name_item *username_list, bool all_dbscale_node) {
  return new MySQLDBScaleEraseAuthInfoNode(this, username_list,
                                           all_dbscale_node);
}
ExecuteNode *MySQLExecutePlan::do_get_dynamic_update_white_node(
    bool is_add, const char *ip, const ssl_option_struct &ssl_option_value,
    const char *comment, const char *user_name) {
  return new MySQLDBScaleDynamicUpdateWhiteNode(
      this, is_add, ip, ssl_option_value, comment, user_name);
}
ExecuteNode *MySQLExecutePlan::do_get_show_monitor_point_status_node() {
  return new MySQLShowMonitorPointStatusNode(this);
}
ExecuteNode *MySQLExecutePlan::do_get_show_global_monitor_point_status_node() {
  return new MySQLShowGlobalMonitorPointStatusNode(this);
}
ExecuteNode *
MySQLExecutePlan::do_get_show_histogram_monitor_point_status_node() {
  return new MySQLShowHistogramMonitorPointStatusNode(this);
}
ExecuteNode *MySQLExecutePlan::do_get_show_outline_monitor_info_node() {
  return new MySQLShowOutlineMonitorInfoNode(this);
}
ExecuteNode *MySQLExecutePlan::do_get_dbscale_create_outline_hint_node(
    dbscale_operate_outline_hint_node *oper) {
  return new MySQLDBScaleCreateOutlineHintNode(this, oper);
}
ExecuteNode *MySQLExecutePlan::do_get_dbscale_flush_outline_hint_node(
    dbscale_operate_outline_hint_node *oper) {
  return new MySQLDBScaleFlushOutlineHintNode(this, oper);
}
ExecuteNode *MySQLExecutePlan::do_get_dbscale_show_outline_hint_node(
    dbscale_operate_outline_hint_node *oper) {
  return new MySQLDBScaleShowOutlineHintNode(this, oper);
}
ExecuteNode *MySQLExecutePlan::do_get_dbscale_delete_outline_hint_node(
    dbscale_operate_outline_hint_node *oper) {
  return new MySQLDBScaleDeleteOutlineHintNode(this, oper);
}
ExecuteNode *MySQLExecutePlan::do_get_com_query_prepare_node(
    DataSpace *dataspace, const char *query_sql, const char *name,
    const char *sql) {
  return new MySQLComQueryPrepareNode(this, dataspace, query_sql, name, sql);
}
ExecuteNode *MySQLExecutePlan::do_get_com_query_exec_prepare_node(
    const char *name, var_item *var_item_list) {
  return new MySQLComQueryExecPrepareNode(this, name, var_item_list);
}
ExecuteNode *MySQLExecutePlan::do_get_com_query_drop_prepare_node(
    DataSpace *dataspace, const char *name, const char *prepare_sql) {
  return new MySQLComQueryDropPrepareNode(this, dataspace, name, prepare_sql);
}
ExecuteNode *MySQLExecutePlan::do_get_dbscale_flush_config_to_file_node(
    const char *file_name, bool flush_all) {
  return new MySQLDBScaleFlushConfigToFileNode(this, file_name, flush_all);
}

ExecuteNode *MySQLExecutePlan::do_get_dbscale_flush_table_info_node(
    const char *schema_name, const char *table_name) {
  return new MySQLDBScaleFlushTableInfoNode(this, schema_name, table_name);
}
ExecuteNode *MySQLExecutePlan::do_get_dbscale_flush_acl_node() {
  return new MySQLDBScaleFlushACLNode(this);
}
ExecuteNode *MySQLExecutePlan::do_get_dbscale_global_consistence_point_node() {
  return new MySQLDBScaleGlobalConsistencePointNode(this);
}
ExecuteNode *MySQLExecutePlan::do_get_show_pool_info_node() {
  return new MySQLDBScaleShowPoolInfoNode(this);
}
ExecuteNode *MySQLExecutePlan::do_get_show_pool_version_node() {
  return new MySQLDBScaleShowPoolVersionNode(this);
}
ExecuteNode *MySQLExecutePlan::do_get_dbscale_set_pool_info_node(
    pool_node *pool_info) {
  return new MySQLResetPoolInfoNode(this, pool_info);
}
ExecuteNode *MySQLExecutePlan::do_get_dbscale_reset_info_plan(
    dbscale_reset_info_op_node *oper) {
  return new MySQLResetInfoPlanNode(this, oper);
}
ExecuteNode *MySQLExecutePlan::do_get_dbscale_block_node() {
  return new MySQLBlockNode(this);
}
ExecuteNode *MySQLExecutePlan::do_get_dbscale_disable_server_node() {
  return new MySQLDisableServer(this);
}
ExecuteNode *MySQLExecutePlan::do_get_dbscale_check_table_node() {
  return new MySQLCheckTableNode(this);
}
ExecuteNode *MySQLExecutePlan::do_get_dbscale_check_disk_io_node() {
  return new MySQLCheckDiskIONode(this);
}
ExecuteNode *MySQLExecutePlan::do_get_dbscale_check_metadata() {
  return new MySQLCheckMetaDataNode(this);
}
ExecuteNode *MySQLExecutePlan::do_get_dbscale_flush_pool_info_node(
    pool_node *pool_info) {
  return new MySQLFlushPoolInfoNode(this, pool_info);
}
ExecuteNode *MySQLExecutePlan::do_get_dbscale_force_flashback_online_node(
    const char *name) {
  return new MySQLForceFlashbackOnlineNode(this, name);
}
ExecuteNode *MySQLExecutePlan::do_get_dbscale_xa_recover_slave_dbscale_node(
    const char *xa_source, const char *top_source, const char *ka_update_v) {
  return new MySQLXARecoverSlaveDBScaleNode(this, xa_source, top_source,
                                            ka_update_v);
}
ExecuteNode *MySQLExecutePlan::do_get_dbscale_purge_connection_pool_node(
    pool_node *pool_info) {
  return new MySQLPurgePoolInfoNode(this, pool_info);
}
ExecuteNode *MySQLExecutePlan::do_get_dbscale_flush_node(
    dbscale_flush_type type) {
  return new MySQLFlushNode(this, type);
}
ExecuteNode *MySQLExecutePlan::do_get_dbscale_flush_weak_pwd_node() {
  return new MySQLFlushWeekPwdFileNode(this);
}
ExecuteNode *MySQLExecutePlan::do_get_dbscale_reload_config_node(
    const char *sql) {
  return new MySQLReloadConfigNode(this, sql);
}
ExecuteNode *MySQLExecutePlan::do_get_dbscale_set_priority_info_node(
    string user_name, int tmp_priority_value) {
  return new MySQLSetPriorityNode(this, user_name, tmp_priority_value);
}
ExecuteNode *MySQLExecutePlan::do_get_show_engine_lock_waiting_node(
    int engine_type) {
  return new MySQLShowEngineLockWaitingNode(this, engine_type);
}
ExecuteNode *MySQLExecutePlan::do_get_show_dataserver_node() {
  return new MySQLDBScaleShowDataServerNode(this);
}
ExecuteNode *MySQLExecutePlan::do_get_show_backend_threads_node() {
  return new MySQLDBScaleShowBackendThreadsNode(this);
}
ExecuteNode *MySQLExecutePlan::do_get_show_partition_scheme_node() {
  return new MySQLDBScaleShowPartitionSchemeNode(this);
}
ExecuteNode *MySQLExecutePlan::do_get_show_schema_node(const char *schema) {
  return new MySQLDBScaleShowSchemaNode(this, schema);
}
ExecuteNode *MySQLExecutePlan::do_get_show_table_node(const char *schema,
                                                      const char *table,
                                                      bool use_like) {
  return new MySQLDBScaleShowTableNode(this, schema, table, use_like);
}
ExecuteNode *MySQLExecutePlan::do_get_migrate_clean_node(
    const char *migrate_id) {
  return new MySQLDBScaleMigrateCleanNode(this, migrate_id);
}
ExecuteNode *MySQLExecutePlan::do_get_show_lock_usage_node() {
  return new MySQLDBScaleShowLockUsageNode(this);
}
ExecuteNode *MySQLExecutePlan::do_get_show_execution_profile_node() {
  return new MySQLDBScaleShowExecutionProfileNode(this);
}

ExecuteNode *MySQLExecutePlan::do_get_select_plain_value_node(
    const char *str_value, const char *alias_name) {
  return new MySQLSelectPlainValueNode(this, str_value, alias_name);
}

ExecuteNode *MySQLExecutePlan::do_get_estimate_select_node(
    DataSpace *dataspace, const char *sql, Statement *statement) {
  return new MySQLEstimateSelectNode(this, dataspace, sql, statement);
}

ExecuteNode *MySQLExecutePlan::do_get_estimate_select_partition_node(
    vector<unsigned int> *par_ids, PartitionedTable *par_table, const char *sql,
    Statement *statement) {
  return new MySQLEstimateSelectNode(this, par_ids, par_table, sql, statement);
}

ExecuteNode *MySQLExecutePlan::do_get_rename_table_node(
    PartitionedTable *old_table, PartitionedTable *new_table,
    const char *old_schema_name, const char *old_table_name,
    const char *new_schema_name, const char *new_table_name) {
  return new MySQLRenameTableNode(this, old_table, new_table, old_schema_name,
                                  old_table_name, new_schema_name,
                                  new_table_name);
}
ExecuteNode *MySQLExecutePlan::do_get_mul_modify_node(
    map<DataSpace *, const char *> &spaces_map,
    map<DataSpace *, int> *sql_count_map, bool need_handle_more_result) {
  return new MySQLMulModifyNode(this, spaces_map, sql_count_map,
                                need_handle_more_result);
}

ExecuteNode *MySQLExecutePlan::do_get_show_partition_node() {
  return new MySQLDBScaleShowPartitionNode(this);
}

ExecuteNode *MySQLExecutePlan::do_get_show_user_sql_count_node(
    const char *user_id) {
  return new MySQLDBScaleShowUserSqlCountNode(this, user_id);
}

ExecuteNode *MySQLExecutePlan::do_get_show_status_node() {
  return new MySQLDBScaleShowStatusNode(this);
}
ExecuteNode *MySQLExecutePlan::do_get_show_catchup_node(
    const char *source_name) {
  return new MySQLShowCatchupNode(this, source_name);
}
ExecuteNode *MySQLExecutePlan::do_get_dbscale_skip_wait_catchup_node(
    const char *source_name) {
  return new MySQLSkipWaitCatchupNode(this, source_name);
}
ExecuteNode *MySQLExecutePlan::do_get_show_async_task_node() {
  return new MySQLDBScaleShowAsyncTaskNode(this);
}
ExecuteNode *MySQLExecutePlan::do_get_clean_temp_table_cache_node() {
  return new MySQLDBScaleCleanTempTableCacheNode(this);
}
ExecuteNode *MySQLExecutePlan::do_get_explain_node(
    bool is_server_explain_stmt_always_extended) {
  return new MySQLDBScaleExplainNode(this,
                                     is_server_explain_stmt_always_extended);
}

ExecuteNode *MySQLExecutePlan::do_get_fetch_explain_result_node(
    list<list<string> > *result, bool is_server_explain_stmt_always_extended) {
  return new MySQLFetchExplainResultNode(
      this, result, is_server_explain_stmt_always_extended);
}

ExecuteNode *MySQLExecutePlan::do_get_show_virtual_map_node(
    PartitionedTable *tab) {
  return new MySQLDBScaleShowVirtualMapNode(this, tab);
}

ExecuteNode *MySQLExecutePlan::do_get_show_shard_map_node(
    PartitionedTable *tab) {
  return new MySQLDBScaleShowShardMapNode(this, tab);
}

ExecuteNode *MySQLExecutePlan::do_get_show_auto_increment_info_node(
    PartitionedTable *tab) {
  return new MySQLDBScaleShowAutoIncInfoNode(this, tab);
}

ExecuteNode *MySQLExecutePlan::do_get_set_auto_increment_offset_node(
    PartitionedTable *tab) {
  return new MySQLDBScaleSetAutoIncrementOffsetNode(this, tab);
}

ExecuteNode *MySQLExecutePlan::do_get_show_transaction_sqls_node() {
  return new MySQLDBScaleShowTransactionSqlsNode(this);
}

ExecuteNode *MySQLExecutePlan::do_get_set_node(DataSpace *dataspace,
                                               const char *sql) {
  return new MySQLSetNode(this, dataspace, sql);
}

ExecuteNode *MySQLExecutePlan::do_get_create_oracle_sequence_node(
    create_oracle_seq_op_node *oper) {
  return new MySQLCreateOracleSequenceNode(this, oper);
}

ExecuteNode *MySQLExecutePlan::do_get_union_all_node(
    vector<ExecuteNode *> &nodes) {
  return new MySQLUnionAllNode(this, nodes);
}

ExecuteNode *MySQLExecutePlan::do_get_union_group_node(
    vector<list<ExecuteNode *> > &nodes) {
  return new MySQLUnionGroupNode(this, nodes);
}

ExecuteNode *MySQLExecutePlan::do_get_keepmaster_node() {
  return new MySQLKeepmasterNode(this);
}

ExecuteNode *MySQLExecutePlan::do_get_dbscale_test_node() {
  return new MySQLDBScaleTestNode(this);
}

ExecuteNode *MySQLExecutePlan::do_get_async_task_control_node(
    unsigned long long id) {
  return new MySQLAsyncTaskControlNode(this, id);
}

ExecuteNode *MySQLExecutePlan::do_get_load_dataspace_file_node(
    const char *filename) {
  return new MySQLLoadDataSpaceFileNode(this, filename);
}

ExecuteNode *MySQLExecutePlan::do_get_call_sp_return_ok_node() {
  return new MySQLCallSPReturnOKNode(this);
}

ExecuteNode *MySQLExecutePlan::do_get_dbscale_purge_monitor_point_node() {
  return new MySQLDBScalePurgeMonitorPointNode(this);
}

ExecuteNode *MySQLExecutePlan::do_get_dbscale_clean_monitor_point_node() {
  return new MySQLDBScaleCleanMonitorPointNode(this);
}

ExecuteNode *MySQLExecutePlan::do_get_send_dbscale_one_column_node(
    bool only_one_row) {
  return new MySQLSendOneColumnToDBScaleNode(this, only_one_row);
}
ExecuteNode *MySQLExecutePlan::do_get_send_dbscale_mul_column_node() {
  return new MySQLSendMulColumnToDBScaleNode(this);
}

ExecuteNode *MySQLExecutePlan::do_get_send_dbscale_one_column_aggr_node(
    bool get_min) {
  return new MySQLSendOneColumnAggrToDBScaleNode(this, get_min);
}

ExecuteNode *MySQLExecutePlan::do_get_send_dbscale_exists_node() {
  return new MySQLSendExistsToDBScaleNode(this);
}

ExecuteNode *MySQLExecutePlan::do_get_dbscale_show_default_session_var_node() {
  return new MySQLDBScaleShowDefaultSessionVarNode(this);
}
ExecuteNode *MySQLExecutePlan::do_get_dbscale_show_version_node() {
  return new MySQLDBScaleShowVersionNode(this);
}
ExecuteNode *MySQLExecutePlan::do_get_show_version_node() {
  return new MySQLShowVersionNode(this);
}
ExecuteNode *MySQLExecutePlan::do_get_show_components_version_node() {
  return new ShowComponentsVersionNode(this);
}
ExecuteNode *MySQLExecutePlan::do_get_dbscale_show_hostname_node() {
  return new MySQLDBScaleShowHostnameNode(this);
}
ExecuteNode *MySQLExecutePlan::do_get_dbscale_show_all_fail_transaction_node() {
  return new MySQLDBScaleShowAllFailTransactionNode(this);
}
ExecuteNode *MySQLExecutePlan::do_get_dbscale_show_detail_fail_transaction_node(
    const char *xid) {
  return new MySQLDBScaleShowDetailFailTransactionNode(this, xid);
}
ExecuteNode *MySQLExecutePlan::do_get_dbscale_show_partition_table_status_node(
    const char *table_name) {
  return new MySQLDBScaleShowPartitionTableStatusNode(this, table_name);
}
ExecuteNode *MySQLExecutePlan::do_get_dbscale_show_schema_acl_info_node(
    bool is_show_all) {
  return new MySQLDBScaleShowSchemaACLInfoNode(this, is_show_all);
}
ExecuteNode *MySQLExecutePlan::do_get_dbscale_show_table_acl_info_node(
    bool is_show_all) {
  return new MySQLDBScaleShowTableACLInfoNode(this, is_show_all);
}
ExecuteNode *MySQLExecutePlan::do_get_dbscale_show_path_info() {
  return new MySQLDBScaleShowPathInfoNode(this);
}
ExecuteNode *MySQLExecutePlan::do_get_dbscale_show_warnings_node() {
  return new MySQLDBScaleShowWarningsNode(this);
}
ExecuteNode *MySQLExecutePlan::do_get_dbscale_show_critical_errors_node() {
  return new MySQLDBScaleShowCriticalErrorNode(this);
}
ExecuteNode *MySQLExecutePlan::do_get_dbscale_clean_fail_transaction_node(
    const char *xid) {
  return new MySQLDBScaleCleanFailTransactionNode(this, xid);
}
ExecuteNode *MySQLExecutePlan::do_get_dbscale_show_base_status_node() {
  return new MySQLDBScaleShowBaseStatusNode(this);
}

ExecuteNode *MySQLExecutePlan::do_get_dbscale_mul_sync_node(
    const char *sync_topic, const char *sync_state, const char *sync_param,
    const char *sync_cond, unsigned long version_id) {
  return new MySQLDBScaleMulSyncNode(this, sync_topic, sync_state, sync_param,
                                     sync_cond, version_id);
}

ExecuteNode *MySQLExecutePlan::do_get_dbscale_add_default_session_var_node(
    DataSpace *dataspace) {
  return new MySQLDBScaleAddDefaultSessionVarNode(this, dataspace);
}
ExecuteNode *
MySQLExecutePlan::do_get_dbscale_remove_default_session_var_node() {
  return new MySQLDBScaleRemoveDefaultSessionVarNode(this);
}

ExecuteNode *MySQLExecutePlan::do_get_federated_table_node() {
  return new MySQLFederatedTableNode(this);
}
ExecuteNode *MySQLExecutePlan::do_get_empty_set_node(int field_num) {
  return new MySQLEmptySetNode(this, field_num);
}
ExecuteNode *MySQLExecutePlan::do_get_cursor_direct_node(DataSpace *dataspace,
                                                         const char *sql) {
  return new MySQLCursorDirectNode(this, dataspace, sql);
}
ExecuteNode *MySQLExecutePlan::do_get_cursor_send_node() {
  return new MySQLCursorSendNode(this);
}
ExecuteNode *MySQLExecutePlan::do_get_return_ok_node() {
  return new MySQLReturnOKNode(this);
}
ExecuteNode *MySQLExecutePlan::do_get_slave_dbscale_error_node() {
  return new MySQLSlaveDBScaleErrorNode(this);
}
ExecuteNode *MySQLExecutePlan::do_get_reset_zoo_info_node() {
  return new MySQLResetZooInfoNode(this);
}
ExecuteNode *MySQLExecutePlan::do_get_set_info_schema_mirror_tb_status_node(
    info_mirror_tb_status_node *tb_status) {
  return new MySQLSetInfoSchemaMirrorTbStatusNode(this, tb_status);
}

ExecuteNode *MySQLExecutePlan::do_get_forward_master_role_node(
    const char *sql, bool is_slow_query) {
  return new MySQLMultipleMasterForwardNode(this, sql, is_slow_query);
}
#ifndef CLOSE_ZEROMQ
ExecuteNode *MySQLExecutePlan::do_get_message_service_node() {
  return new MySQLMessageServiceNode(this);
}
ExecuteNode *MySQLExecutePlan::do_get_binlog_task_node() {
  return new MySQLBinlogTaskNode(this);
}
ExecuteNode *MySQLExecutePlan::do_get_task_node() {
  return new MySQLTaskNode(this);
}
ExecuteNode *MySQLExecutePlan::do_get_binlog_task_add_filter_node() {
  return new MySQLBinlogTaskAddFilterNode(this);
}
ExecuteNode *MySQLExecutePlan::do_get_drop_task_filter_node() {
  return new MySQLDropTaskFilterNode(this);
}
ExecuteNode *MySQLExecutePlan::do_get_drop_task_node() {
  return new MySQLDropTaskNode(this);
}
ExecuteNode *MySQLExecutePlan::do_get_show_client_task_status_node(
    const char *task_name, const char *server_task_name) {
  return new MySQLShowClientTaskStatusNode(this, task_name, server_task_name);
}
ExecuteNode *MySQLExecutePlan::do_get_show_server_task_status_node(
    const char *task_name) {
  return new MySQLShowServerTaskStatusNode(this, task_name);
}
#endif

ExecuteNode *MySQLExecutePlan::do_get_dbscale_update_audit_user_node(
    const char *username, bool is_add) {
  return new MySQLDBScaleUpdateAuditUserNode(this, username, is_add);
}

ExecuteNode *MySQLExecutePlan::do_get_connect_by_node(
    ConnectByDesc connect_by_desc) {
  return new MySQLConnectByNode(this, connect_by_desc);
}

ExecuteNode *MySQLExecutePlan::do_get_dbscale_show_create_oracle_seq_node(
    const char *seq_schema, const char *seq_name) {
  return new MySQLDBScaleShowCreateOracleSeqPlan(this, seq_schema, seq_name);
}
ExecuteNode *MySQLExecutePlan::do_get_dbscale_show_seq_status_node(
    const char *seq_schema, const char *seq_name) {
  return new MySQLDBScaleShowSeqStatusPlan(this, seq_schema, seq_name);
}
ExecuteNode *
MySQLExecutePlan::do_get_dbscale_show_fetchnode_buffer_usage_node() {
  return new MySQLDBScaleShowFetchNodeBufferNode(this);
}
ExecuteNode *MySQLExecutePlan::do_get_dbscale_show_trx_block_info_node(
    bool is_local) {
  return new MySQLDBScaleShowTrxBlockInfoNode(this, is_local);
}
ExecuteNode *MySQLExecutePlan::do_get_restore_recycle_table_precheck_node(
    const char *from_schema, const char *from_table, const char *to_table,
    const char *recycle_type, DataSpace *dspace) {
  return new MySQLRestoreRecycleTablePrecheckNode(
      this, from_schema, from_table, to_table, recycle_type, dspace);
}

ExecuteNode *MySQLExecutePlan::do_get_dbscale_internal_set_node() {
  return new MySQLDBScaleInternalSetNode(this);
}

ExecuteNode *MySQLExecutePlan::do_get_empty_node() {
  return new MySQLEmptyNode(this);
}

ExecuteNode *MySQLExecutePlan::do_get_dbscale_show_prepare_cache_node() {
  return new MySQLDBScaleShowPrepareCacheNode(this);
}

ExecuteNode *MySQLExecutePlan::do_get_dbscale_flush_prepare_cache_hit_node() {
  return new MySQLDBScaleFlushPrepareCacheHitNode(this);
}

bool MySQLExecutePlan::has_duplicate_entry_in_error_packet(Packet *packet) {
  if (packet) {
    MySQLErrorResponse error(packet);
    error.unpack();
    if (error.get_error_code() == 1062) return true;
  }
  return false;
}

bool MySQLExecutePlan::check_select_error_not_rollback_in_packet(
    Packet *packet) {
  bool should_rollback = false;
  // get_migrate_tool not null, means part table select error.
  if (get_migrate_tool() != NULL) {
    should_rollback = get_migrate_tool()->check_select_error_not_rollback();
    return should_rollback;
  }
  // directexecutenode select error
  if (packet) {
    MySQLErrorResponse error(packet);
    error.unpack();
    if (error.get_error_code() == ER_LOCK_WAIT_TIMEOUT) {
      LOG_DEBUG(
          "check_select_error_not_rollback_in_packet get error code "
          "ER_LOCK_WAIT_TIMEOUT.\n");
      InnodbRollbackOnTimeout single_server_innodb_rollback_on_timeout =
          get_single_server_innodb_rollback_on_timeout();
#ifndef DBSCALE_TEST_DISABLE
      Backend *bk = Backend::instance();
      dbscale_test_info *test_info = bk->get_dbscale_test_info();
      if (!strcasecmp(test_info->test_case_name.c_str(), "rollback_error") &&
          !strcasecmp(test_info->test_case_operation.c_str(),
                      "innodb_rollback_on_timeout_on")) {
        LOG_DEBUG("Test transaction with innodb_rollback_on_timeout on.\n");
        should_rollback = true;
      } else {
        should_rollback = single_server_innodb_rollback_on_timeout ==
                          INNODB_ROLLBACK_ON_TIMEOUT_ON;
      }
#else
      should_rollback = single_server_innodb_rollback_on_timeout ==
                        INNODB_ROLLBACK_ON_TIMEOUT_ON;
#endif
    } else if (error.get_error_code() == ER_LOCK_DEADLOCK ||
               error.is_shutdown()) {
      LOG_DEBUG(
          "check_select_error_not_rollback_in_packet find dead lock or lost "
          "connection.\n");
      should_rollback = true;  // deadlock and lost connection must rollback
    }
    if (!should_rollback) {
      LOG_DEBUG(
          "check_select_error_not_rollback_in_packet check should_rollback is "
          "false.\n");
      string error_message = string(error.get_error_message());
      error_message.append(
          ". due to innodb_rollback_on_timeout_on is off. this transaction not "
          "restart.");
      error.set_error_message(error_message.c_str());
      error.pack(packet);
    }
  }
  return should_rollback;
}

void MySQLExecutePlan::do_send_error_packet() {
  if (is_dispatch_federated()) {
    ((MySQLDispatchPacketNode *)start_node)->dispatch_error_packet();
  } else {
    Packet *packet;
    packet = ((MySQLExecuteNode *)start_node)->get_error_packet();
    if (packet) {
      MySQLErrorResponse error(packet);
      error.unpack();
      LOG_INFO(
          "get an error packet, %d (%s) %s, and try to send it to client.\n",
          error.get_error_code(), error.get_sqlstate(),
          error.get_error_message());
      session->acquire_has_send_client_error_packet_mutex();
      if (session->get_has_send_client_error_packet()) {
        session->release_has_send_client_error_packet_mutex();
        LOG_DEBUG(
            "Session has send the error packet to client, so ignore this error "
            "packet.\n");
        return;
      }
      session->set_has_send_client_error_packet();
      session->release_has_send_client_error_packet_mutex();
      session->set_cur_stmt_error_code(error.get_error_code());
      if ((error.get_error_code() == ERROR_AUTH_DENIED_CODE) &&
          !strcmp(error.get_sqlstate(), "42000")) {
        string msg = error.get_error_message();
        if ((msg.find("Access denied for user") != string::npos) &&
            (msg.find("to database 'information_schema'") != string::npos) &&
            !lower_case_compare(session->get_schema(), default_login_schema)) {
          msg.append(". do you forget to use database?");
          error.set_error_message(msg.c_str());
          Packet pkt;
          error.pack(&pkt);
          handler->send_to_client(&pkt);
          return;
        }
      }
      handler->set_mul_stmt_send_error_packet(true);
      handler->send_to_client(packet);
    } else {
      if (is_send_cluster_xa_transaction_ddl_error_packet()) {
        string err_message =
            "XAER_RMFAIL: The command cannot be executed when global "
            "transaction is in the  ";
        err_message.append(session
                               ->cluster_xa_transaction_to_string(
                                   session->get_cluster_xa_transaction_state())
                               .c_str());
        err_message.append(" state");
        Packet error_packet;
        MySQLErrorResponse error(ERROR_XAER_RMFAIL_CODE, err_message.c_str(),
                                 "XAE07");
        error.pack(&error_packet);
        session->acquire_has_send_client_error_packet_mutex();
        if (session->get_has_send_client_error_packet()) {
          session->release_has_send_client_error_packet_mutex();
          LOG_DEBUG(
              "Session has send the error packet to client, so ignore this "
              "error "
              "packet.\n");
          return;
        }
        session->set_has_send_client_error_packet();
        session->release_has_send_client_error_packet_mutex();
        session->set_cur_stmt_error_code(error.get_error_code());
        handler->send_to_client(&error_packet);
        set_send_cluster_xa_transaction_ddl_error_packet(false);
        return;
      }
      LOG_ERROR(
          "MySQLExecutePlan::do_send_error_packet fail to find an error "
          "packet.\n");
      throw Error("Get an error packet.");
    }
  }
}

void MySQLExecutePlan::do_fullfil_error_info(unsigned int *error_code,
                                             string *sql_state) {
  Packet *packet;
  packet = ((MySQLExecuteNode *)start_node)->get_error_packet();
  if (packet) {
    MySQLErrorResponse response(packet);
    response.unpack();
    *error_code = (unsigned int)response.get_error_code();
    sql_state->clear();
    sql_state->append(response.get_sqlstate());
  }
}

/* class MySQLExecuteNode */

MySQLExecuteNode::MySQLExecuteNode(ExecutePlan *plan, DataSpace *dataspace)
    : ExecuteNode(plan, dataspace) {
  this->driver = (MySQLDriver *)plan->driver;
  this->session = (MySQLSession *)plan->session;
  this->handler = (MySQLHandler *)plan->handler;
  this->name = "MySQLExecuteNode";
  this->profile_id = -1;
  status = EXECUTE_STATUS_START;
  ready_rows = new AllocList<Packet *, Session *, StaticAllocator<Packet *> >();
  ready_rows->set_session(plan->session);
  by_add_pre_disaster_master = false;
}

/* class MySQLInnerNode */

MySQLInnerNode::MySQLInnerNode(ExecutePlan *plan, DataSpace *dataspace)
    : MySQLExecuteNode(plan, dataspace) {
  this->name = "MySQLInnerNode";
  all_children_finished = false;
#ifndef DBSCALE_TEST_DISABLE
  loop_count = 0;
  need_record_loop_count = false;
#endif
  node_can_swap = false;
  one_child_got_error = false;
  thread_started = false;
  ready_rows_buffer_size = 0;
}

Packet *MySQLInnerNode::get_error_packet() {
  list<MySQLExecuteNode *>::iterator it;
  for (it = children.begin(); it != children.end(); ++it) {
    if ((*it)->get_error_packet()) {
      return (*it)->get_error_packet();
    }
  }

  return NULL;
}

void MySQLInnerNode::children_execute() {
#ifdef DEBUG
  LOG_DEBUG("Node %@ children start to execute.\n", this);
#endif
  list<MySQLExecuteNode *>::iterator it;
  for (it = children.begin(); it != children.end(); ++it) {
    (*it)->execute();
    if ((*it)->is_got_error()) {
      break;
    }
    node_can_swap = node_can_swap & (*it)->can_swap();
  }
  if (it != children.end()) {
#ifdef DEBUG
    LOG_DEBUG(
        "Node %@ children execute finished, but some child do not execute "
        "because previous child got error.\n",
        this);
#endif
    handle_error_all_children();
  } else {
#ifdef DEBUG
    LOG_DEBUG("Node %@ children execute finished.\n", this);
#endif
  }
}

bool MySQLInnerNode::notify_parent() {
  Packet *row;
  if (ready_rows->empty()) {
    return false;
  }

  while (!ready_rows->empty()) {
    row = ready_rows->front();
    ready_rows->pop_front();
    parent->add_row_packet(this, row);
  }
  ready_rows_buffer_size = 0;
  return true;
}

void MySQLInnerNode::set_children_error() {
  list<MySQLExecuteNode *>::iterator it;
  for (it = children.begin(); it != children.end(); ++it) {
    (*it)->set_node_error();
  }
}

void MySQLInnerNode::set_children_thread_status_start() {
  list<MySQLExecuteNode *>::iterator it;
  for (it = children.begin(); it != children.end(); ++it) {
    (*it)->set_thread_status_started();
  }
}

void MySQLInnerNode::handle_error_all_children() {
  list<MySQLExecuteNode *>::iterator it;
  for (it = children.begin(); it != children.end(); ++it) {
    try {
      (*it)->handle_error_throw();
    } catch (...) {
      it++;
      for (; it != children.end(); it++) {
        try {
          (*it)->handle_error_throw();
        } catch (...) {
        }
      }
      throw;
    }
  }
}

void MySQLInnerNode::wait_children() {
#ifdef DEBUG
  LOG_DEBUG("Node %@ %s start to wait.\n", this, this->name);
#endif
  if (all_children_finished) {
    handle_error_all_children();
    status = EXECUTE_STATUS_BEFORE_COMPLETE;
  } else {
    list<MySQLExecuteNode *>::iterator it;
    for (it = children.begin(); it != children.end(); ++it) {
      (*it)->start_thread();
    }
    set_children_thread_status_start();
    plan->start_all_bthread();

    unsigned int finished_child = 0;

    for (it = children.begin(); it != children.end(); ++it) {
      if (!(*it)->notify_parent() && (*it)->is_finished()) {
        finished_child++;
      }
      if ((*it)->is_got_error()) {
        one_child_got_error = true;
      }
#ifndef DBSCALE_TEST_DISABLE
      if (need_record_loop_count && loop_count++ == 10) {
        LOG_DEBUG(
            "throw ExecuteNodeError to test for option "
            "'max-fetchnode-ready-rows-size'\n");
        ACE_Time_Value sleep_tv(2, 0);
        ACE_OS::sleep(sleep_tv);
        throw ExecuteNodeError(
            "test for option 'max-fetchnode-ready-rows-size'");
      }
#endif
    }

    if (finished_child == children.size()) {
      handle_error_all_children();
      all_children_finished = true;
      status = EXECUTE_STATUS_BEFORE_COMPLETE;
    } else {
      status = EXECUTE_STATUS_HANDLE;
    }
  }
#ifdef DEBUG
  LOG_DEBUG("Node %@ %s wait finished.\n", this, this->name);
#endif
}

void MySQLInnerNode::init_row_map() {
  list<MySQLExecuteNode *>::iterator it;
  for (it = children.begin(); it != children.end(); ++it) {
    row_map[*it] =
        new AllocList<Packet *, Session *, StaticAllocator<Packet *> >();
    row_map[*it]->set_session(plan->session);
    row_map_size[*it] = 0;
    buffer_row_map_size[*it] = 0;
  }
}

void MySQLInnerNode::clean() {
  Packet *packet;
  MySQLExecuteNode *free_node;

  status = EXECUTE_STATUS_COMPLETE;

  // clean ready packets
  while (!ready_rows->empty()) {
    packet = ready_rows->front();
    ready_rows->pop_front();
    delete packet;
  }

  while (!children.empty()) {
    free_node = children.front();
    free_node->clean();

    // clean remaining rows
    if (row_map[free_node]) {
      while (!row_map[free_node]->empty()) {
        packet = row_map[free_node]->front();
        row_map[free_node]->pop_front();
        delete packet;
      }

      delete row_map[free_node];
      row_map[free_node] = NULL;
    }

    // delete child node
    children.pop_front();
    delete free_node;
  }

  do_clean();
}

void MySQLInnerNode::handle_swap_connections() {
  if (!plan->get_connection_swaped_out()) {
    plan->set_connection_swaped_out(true);
    list<MySQLExecuteNode *>::iterator it;
    int conn_num = 0;
    for (it = children.begin(); it != children.end(); ++it) {
      Connection *conn = (*it)->get_connection_from_node();
      if (conn) {
        conn->set_session(session);
        struct event *conn_event = conn->get_conn_socket_event();
        evutil_socket_t conn_socket = conn->get_conn_socket();
        SocketEventBase *conn_base = conn->get_socket_base();
#ifdef DEBUG
        ACE_ASSERT(conn_base);
#endif
        session->add_server_base(conn_socket, conn_base, conn_event);
        LOG_DEBUG(
            "Finish to prepare the conn socket session swap for conn %@ and "
            "session %@.\n",
            conn, session);
        conn_num++;
      }
    }
    session->set_mul_connection_num(conn_num);
  }
}

/* class MySQLClusterXATransactionNode */
MySQLClusterXATransactionNode::MySQLClusterXATransactionNode(ExecutePlan *plan)
    : MySQLExecuteNode(plan) {
  this->name = "MySQLClusterXATransactionNode";
  error_packet = NULL;
  packet = NULL;
  xa_conn = NULL;
  dataspace = NULL;
  got_error = false;
  st_type = plan->statement->get_stmt_node()->type;
  xa_sql = plan->statement->get_sql();
}
void MySQLClusterXATransactionNode::handle_send_client_packet(
    Packet *packet, bool is_row_packet) {
  handler->send_mysql_packet_to_client_by_buffer(packet, is_row_packet);
}
void MySQLClusterXATransactionNode::handle_error_packet(Packet *packet) {
  status = EXECUTE_STATUS_COMPLETE;
  error_packet = packet;
  MySQLErrorResponse response(error_packet);
  response.unpack();
  LOG_DEBUG(
      "MySQLClusterXATransactionNode get an error packet when execute xa_sql "
      "[%s]: %d (%s) "
      "%s\n",
      xa_sql, response.get_error_code(), response.get_sqlstate(),
      response.get_error_message());
  if (response.is_shutdown()) {
    if (xa_conn) {
      handler->clean_dead_conn(&xa_conn, dataspace);
    }
  }
  throw ErrorPacketException();
}

void MySQLClusterXATransactionNode::handle_more_result(Packet *packet) {
  try {
    handler->receive_from_server(xa_conn, packet);
    while (!driver->is_eof_packet(packet)) {
      if (driver->is_error_packet(packet)) {
        handle_error_packet(packet);
      }
      handle_send_client_packet(packet, false);

      handler->receive_from_server(xa_conn, packet);
    }
    handle_send_client_packet(packet, false);
    MySQLEOFResponse eof(packet);
    eof.unpack();
    // receive rows and last eof
    handler->receive_from_server(xa_conn, packet);
#ifndef DBSCALE_TEST_DISABLE
    Backend *bk = Backend::instance();
    dbscale_test_info *test_info = bk->get_dbscale_test_info();
    if (!strcasecmp(test_info->test_case_name.c_str(), "client_exception") &&
        !strcasecmp(test_info->test_case_operation.c_str(),
                    "client_exception")) {
      delete packet;
      packet = Backend::instance()->get_new_packet(DEFAULT_PACKET_SIZE,
                                                   session->get_packet_alloc());
      LOG_DEBUG("test after delete packet, then ClientBroken\n");
      throw ClientBroken();
    }
#endif
    while ((!driver->is_eof_packet(packet)) &&
           (!driver->is_error_packet(packet))) {
      handle_send_client_packet(packet, true);
      handler->receive_from_server(xa_conn, packet);
    }
    if (driver->is_error_packet(packet)) handle_error_packet(packet);
    if (driver->is_eof_packet(packet)) {
      if (support_show_warning)
        handle_warnings_OK_and_eof_packet(plan, packet, handler, dataspace,
                                          xa_conn);
    }
#ifndef DBSCALE_TEST_DISABLE
    handler->handler_last_send.start_timing();
#endif
    handle_send_client_packet(packet, false);
    handler->flush_net_buffer();
#ifndef DBSCALE_TEST_DISABLE
    handler->handler_last_send.end_timing_and_report();
#endif
  } catch (...) {
    this->packet = packet;
    throw;
  }

  this->packet = packet;
}

void MySQLClusterXATransactionNode::execute() {
  Backend *backend = Backend::instance();
  string xid_str = "";
  size_t start_pos = 0;
  size_t end_pos = 0;
  dataspace = backend->get_catalog();

  if (session->get_session_state() == SESSION_STATE_WORKING) {
#ifdef DEBUG
    node_start_timing();
#endif
    LOG_DEBUG("MySQLClusterXATransactionNode sql : %s .\n", xa_sql);

    packet = backend->get_new_packet(DEFAULT_PACKET_SIZE, NULL);
    Packet exec_packet(DEFAULT_PACKET_SIZE, NULL);

    try {
      Packet *real_exec_packet = NULL;
      MySQLQueryRequest query(xa_sql);
      query.set_sql_replace_char(
          plan->session->get_query_sql_replace_null_char());
      query.pack(&exec_packet);
      real_exec_packet = &exec_packet;

#ifndef DBSCALE_TEST_DISABLE
      handler->send_op.start_timing();
#endif

      xa_conn = handler->send_to_server_retry(dataspace, real_exec_packet,
                                              session->get_schema(), false);

      if (!xa_conn) {
        LOG_ERROR("fail to get connections to execute xa command.\n");
        throw Error("fail to get connections to execute xa command");
      } else {
        xa_conn->set_cluster_xa_session(session);
      }
#ifndef DBSCALE_TEST_DISABLE
      handler->send_op.end_timing_and_report();
#endif
    } catch (ExecuteNodeError &e) {
      got_error = true;
      if (xa_conn) {
        handler->clean_dead_conn(&xa_conn, dataspace);
      }
      status = EXECUTE_STATUS_COMPLETE;
      throw e;
    } catch (exception &e) {
      status = EXECUTE_STATUS_COMPLETE;
      LOG_ERROR("MySQLClusterXATransactionNode fail due to exception [%s].\n",
                e.what());
      string error_message(
          "MySQLClusterXATransactionNode fail due to exception:");
      error_message.append(e.what());
      got_error = true;
      if (xa_conn) {
        handler->clean_dead_conn(&xa_conn, dataspace);
      }
      throw ExecuteNodeError(error_message.c_str());
    }
  }
  /*receive packet*/
  try {
    bool has_more_result = false;

    do {
      handler->receive_from_server(xa_conn, packet);
      if (driver->is_error_packet(packet)) {
        LOG_DEBUG("MySQLClusterXATransactionNode : receive error packet.\n");
        has_more_result = false;
        handle_error_packet(packet);
      } else if (driver->is_ok_packet(packet)) {
        MySQLOKResponse ok(packet);
        ok.unpack();
        has_more_result = ok.has_more_result();
        LOG_DEBUG("MySQLClusterXATransactionNode : receive ok packet.\n");
        handler->send_to_client(packet);
        if (support_show_warning)
          handle_warnings_OK_and_eof_packet(plan, packet, handler, dataspace,
                                            xa_conn);
      } else if (driver->is_result_set_header_packet(packet)) {
        LOG_DEBUG(
            "MySQLClusterXATransactionNode : receive result_set packet.\n");
        handle_send_client_packet(packet, false);
        handle_more_result(packet);
        has_more_result = false;
      } else {
#ifdef DEBUG
        ACE_ASSERT(0);  // should not be here
#endif
        handle_send_client_packet(packet, false);
        has_more_result = false;
      }
#ifdef DEBUG
      LOG_DEBUG("Has more result %d.\n", has_more_result ? 1 : 0);
#endif
    } while (has_more_result);
    switch (st_type) {
      case STMT_XA_START_TRANSACTION:
        start_pos =
            plan->statement->get_stmt_node()->xid_item->xid_start_pos - 1;
        end_pos = plan->statement->get_stmt_node()->xid_item->xid_end_pos;
        xid_str = string(xa_sql, start_pos, end_pos - start_pos);
        LOG_DEBUG(
            "start_pos is %u, end_pos is %u, xa start transaction with xid "
            "%s.\n",
            start_pos, end_pos, xid_str.c_str());
        session->set_session_cluster_xid(xid_str);
        session->set_cluster_xa_transaction_conn(xa_conn);
        session->set_cluster_xa_transaction_state(SESSION_XA_TRX_XA_ACTIVE);
        /* after receive STMT_XA_START_TRANSACTION,
         * we should set xa session.*/
        xa_conn->set_cluster_xa_session(session);
        break;
      case STMT_XA_END_TRANSACTION:
        session->set_cluster_xa_transaction_state(SESSION_XA_TRX_XA_IDLE);
        break;
      case STMT_XA_PREPARE_TRANSACTION:
        session->set_cluster_xa_transaction_state(SESSION_XA_TRX_XA_PREPARED);
        break;
      case STMT_XA_COMMIT_TRANSACTION:
      case STMT_XA_COMMIT_ONE_PHASE_TRANSACTION:
      case STMT_XA_ROLLBACK_TRANSACTION:
        session->reset_cluster_xa_transaction();
        handler->put_back_connection(dataspace, xa_conn);
        xa_conn = NULL;
        break;
      default:
        break;
    }
  } catch (ErrorPacketException &e) {
    LOG_DEBUG(
        "MySQLClusterXATransactionNode get an error packet when execute xa_sql "
        "[%s].\n",
        xa_sql);
    status = EXECUTE_STATUS_COMPLETE;
    if (xa_conn && error_packet) {
      handler->put_back_connection(dataspace, xa_conn);
      xa_conn = NULL;
    }
    throw e;
  } catch (ExecuteNodeError &e) {
    got_error = true;
    if (xa_conn) {
      handler->clean_dead_conn(&xa_conn, dataspace);
    }
    status = EXECUTE_STATUS_COMPLETE;
    throw e;
  } catch (exception &e) {
    status = EXECUTE_STATUS_COMPLETE;
    LOG_ERROR("MySQLClusterXATransactionNode fail due to exception [%s].\n",
              e.what());
    string error_message(
        "MySQLClusterXATransactionNode fail due to exception:");
    error_message.append(e.what());
    got_error = true;
    if (xa_conn) {
      handler->clean_dead_conn(&xa_conn, dataspace);
    }
    throw ExecuteNodeError(error_message.c_str());
  }

#ifdef DEBUG
  nod